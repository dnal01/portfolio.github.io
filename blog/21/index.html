<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Twentieth First - Web Portfolio of Denys</title>
    <link rel="stylesheet" type="text/css" href="../../main.css">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    
</head>

<body>
    <header>
        <ul class="navigation">
            <li class="navigation-item"><a class="item-link" href="../../index.html">Home</a></li>
            <li class="navigation-item"><a class="item-link" href="../../blog/index.html">Blog</a></li>
            <li class="navigation-item"><a class="item-link" href="../../projects/index.html">Projects</a></li>
            <li class="navigation-item"><a class="item-link" href="../../contact/index.html">Contact</a></li>
        </ul>
    </header>
    <main>
        <h1 class="title">Twentieth First</h1>
        <p class="left date">January 19, 2025</p>
        <div class="block left">
            <section>
                <h2>Java</h2>
                <h3>Variable initialization - additional character</h3>
                    <ul>
                        <li><code class="highlighter-rouge">byte a = 10;</code> 8 bit. Range from -128 to 127;</li>
                        <li><code class="highlighter-rouge">short s = 10000;</code> 16 bit. Range from -32768 to 32767;</li>
                        <li><code class="highlighter-rouge">int cost = 133_452_667</code> Range from -2,147,483,684 to 2,147,483,647. <code>_</code> is for readability;</li>
                        <li><code class="highlighter-rouge">long <i>a</i> = 123125415l or L;</code></li>
                        <li><code class="highlighter-rouge">float <i>b</i> = 2.1E12f or F;</code></li>
                        <li><code class="highlighter-rouge">boolean <i>c</i> = !(x > 5 && x < 10);</code></li>
                        <li><code class="highlighter-rouge">String <i>d</i> = new String(arrayName);</code></li>
                        <li><code class="highlighter-rouge">double price1 = 9.99, price2 = 12.99;</code></li>
                    </ul>
                    <p>If uninitialized, variables have a default value:</p>
                    <ul>
                        <li><code class="highlighter-rouge">int</code>: <strong>0</strong></li>
                        <li><code class="highlighter-rouge">String</code>: <strong>null</strong></li>
                        <li><code class="highlighter-rouge">boolean</code>: <strong>false</strong></li>
                    </ul>
                    <h3>Constants</h3>
                    <p>Use <code class="highlighter-rouge">final</code> word before initialization of a variable.</p>
                <h3>Theory</h3>
                    <p>Classes consist of methods and data; Packages - folder where the class will be saved;</p>
                    <p>Classes are Templates (they are singles), Objects are Individual elements created from classes.</p>
                    <p>Encapsulation - definition of methods instead of using direct access to the variables.</p>
                    <p>Polymorphism - allows use of sub-classes` objects as object of parent. It allows a single method to interact with object from different classes.</p>
                    <p>Abstractions - defines general characteristics of objects, ignoring details of their realization. It is a compelling reason to use abstract classes, as long as the “is-a” relationship is preserved.</p>
                        <ul>
                            <li>A class can extend only one Abstraction.</li>
                        </ul>
                    <p>Interfaces - defines some function, which does not have concrete realization, which is then implemented by classes which use this interfaces.</p>
                    <p>Methods form the object's interface with the outside world; the buttons on the front of your television set, for example, are the interface between you and the electrical wiring on the other side of its plastic casing. You press the "power" button to turn the television on and off.</p>
                        <ul>
                            <li>Describes the behaver, but not a type.</li>
                            <li>The access modifiers are not specified.</li>
                        </ul>
                    <p>Override of methods - change of the functional in a sub-class, if a sub-class has the same method, which is defined in a parent class (super class).</p>
                <h3>Data Conversion</h3>
                <p>Downgrade of a type is possible only with explicit conversion, e.g. int into a char.</p>
<pre><code>int a = 128;
long b = a; // Implicit Type Data conversion
long b = (long) a; // Explicit Type Data Conversion</code></pre>
                <h3>Mandatory code</h3>
                    <pre><code>public class nameOfTheFile {
    public static void main(String[] args) {
- Classes goes here}
}</code></pre>
                <h3>Classes initialization and usage</h3>
                    <p>new Classes need to be in another <code class="highlighter-rouge">.java</code> file. <i>This information needs to be confirmed.</i></p>
                    <pre><code>public class Customer {
    - data (called fields);
    String name;
    String size = "S";
    - Operations (called methods);
    void setSize (String newSize) {
        size = newSize;
    }
    String getSize() {
        return size;
    }                         
}</code></pre>
                    <p>Then use the class in methods of other classes</p>
                    <pre><code>Customer person1 = new Customer();
    person1.name = "Bob";
    System.out.println(person1.name);</code></pre>
                <h3>Methods initialization</h3>
                    <pre><code>&lt;access modifier&gt; &lt;return type&gt; &lt;method name&gt; (&lt;parameter list&gt;) {
    /* method body */
    /* return statement */
}</code></pre>
                    <pre><code>public static double <i>subtract</i>(int a, int b) {
    int result = a - b;
    return (double) result;
}

int subResult = subtract(10, 5); // the method call</code></pre>
                    <p>This method consist of the following parts:</p>
                    <ul>
                        <li><code class="highlighter-rouge">public static</code> - modification</li>
                        <li><code class="highlighter-rouge">double</code> - type of the result that is returned</li>
                        <li><code class="highlighter-rouge">subtract</code> - method name</li>
                        <li><code class="highlighter-rouge">int a, int b</code> - input</li>
                        <li><code class="highlighter-rouge">return (double) result</code> - if a method is a void, than write just <code>return;</code></li>
                    </ul>
                    <p>Name of methods should begin with a verb and written in lowerCamelCase.</p>
                    <h3>Access Modifiers</h3>
                    <table>
                        <tr>
                            <th>Access Modifier</th>
                            <th>Visibility Scope</th>
                        </tr>
                        <tr>
                            <td><code class="highlighter-rouge">public</code></td>
                            <td>All classes</td>
                        </tr>
                        <tr>
                            <td><code class="highlighter-rouge">protected</code></td>
                            <td>Classes in the same package and subclasses.<br>This is true even if the subclass is not located in the same package as the superclass.</td>
                        </tr>
                        <tr>
                            <td>default (no access modifier)</td>
                            <td>Classes in the same package</td>
                        </tr>
                        <tr>
                            <td><code class="highlighter-rouge">private</code></td>
                            <td>Some Classes</td>
                        </tr>
                    </table>
                    <p><i>Note that classes can only be either default or public.</i></p>
                    <h3>Encapsulation</h3>
                    <p>Hiding variables and allowing access to data through Methods only is called <strong>Encapsulation</strong>.</p>
                    <h3>Using Method overloading</h3>
                    <p>Class can define several methods that:</p>
                    <ul>
                        <li>Have the same name</li>
                        <li>Have different signatures</li>
                            <ul>
                                <li>The <strong>number</strong> of parameters</li>
                                <li>The <strong>types</strong> of parameters</li>
                            </ul>
                    </ul>
                    <p>Overloading is convenient for invokers.</p>
                    <pre><code>public class Clothing {
    public boolean fit(int size) {...}
    public boolean fit(String size) {...}
    public boolean fit(int height, int width) {...}
}</code></pre>
                <h3>Variable Shadowing</h3>
                <pre><code>public class Clothing {
    double <strong>price</strong>;
    public void setPrice(String <strong style="color: red;">price</strong>) {
        <strong>this.price</strong> = <strong style="color: red;">price</strong>;
    }
}</code></pre>
                <h3>Package initialization</h3>
                    <pre><code>package duke.choice;</code></pre>
                    <p><code class="highlighter-rouge">duke</code> - is the main folder; <code class="highlighter-rouge">choice</code> - is a subfolder.</p>
                <h3>Switch Statement</h3>
                <pre><code>... String condition = "Used";
    switch (condition) {
    case "Damaged", "Returned":
        discount = price * 0.1;
        break;
    case "Used":
        discount = price * 0.2;
        break;
    default:
        discount = price;
                </code></pre>
                <h3>Array</h3>
                <pre><code>int[] numbers = {1, 2, 3};
int numbers[] = {1, 2, 3};

for (int i = 0; i < numbers.length; i++) {
    System.out.println(numbers[i]);
}

for (int number : numbers) {
    System.out.println(number);
}</code></pre>
                <p>Loops are running until an expression is false.</p>
                <pre><code>int[] numbers = new int[4];</code></pre>
                <p>In this case an empty array of length of 4 is created.</p>
                <pre><code>String name = "Bob";
char[] chars = name.toCharArray();
chars[0]; // = 'B'
String newName = new String(chars);</code></pre>
                <p>Transformation of string into array of characters and vice versa.</p>
                <pre><code>import java.until.Arrays;
String toString = Arrays.toString(numbers);</code></pre>
                <p>Transforms the array into a string.</p>
                <pre><code>String[] nameParts = fullName.split(" ");</code></pre>
                <p>Splits a string onto parts based on character</p>
                <h3>String Methods</h3>
                <ul>
                    <li><code class="highlighter-rouge">String upperCaseName = newName.toUpperCase();</code></li>
                    <li><code class="highlighter-rouge">String loverCaseName = newName.toLoverCase();</code></li>
                    <li><code class="highlighter-rouge">String isEmpty = newName.isEmpty();</code></li>
                    <li><code class="highlighter-rouge">String substring = newName.substring(1, 2);</code> beginIndex (including) and endIndex (excluding), where the String will be cut.</li>
                    <li><code class="highlighter-rouge">int indexOf = newName.indexOf('=');</code> find an index of a specific char.</li>
                    <li><code class="highlighter-rouge">char charAtIndexOne = newName.charAt(1);</code> 'o' at index 1.</li>
                    <li><code class="highlighter-rouge">String stringLength = String.length();</code> It is different to .length, which works on arrays.</li>
                    <li><code class="highlighter-rouge">String trim = " How ".trim()</code> Eliminates spaces.</li>
                    <li><code class="highlighter-rouge">String numberValue = String.valueOf(10);</code> It can handle converting boolean, char, char array, double, float, int, long, and Object types into their respective string representations.</li>
                    <li><code class="highlighter-rouge">String equals = newName.equals("Bob");</code> Object types are compared by <code>equals()</code> method. Primitive by <code>==</code>. There is also a <code>equalsIgnoreCase()</code> method.</li>
                    <li><code class="highlighter-rouge">String concat = newName.concat(previousName);</code> Or use <code>+</code>`s.</li>
                </ul>
                <h3>String builder class</h3>
                <pre><code>StringBuilder builder = new StringBuilder();
builder.append("hello").append("world").append(31);

builder.reverse();
String reverseString = builder.toString();</code></pre>
                <p>The advantage of a string builder to simple concatenation is that it creates only one String in memory during appending. Less memory usage.</p>
                <pre><code>String result = new String();
char[] reverses = input.toCharArray();
for (int i = reverses.length-1; i >= 0; i--) {
    result += reverses[i];
}</code></pre>
                <p>Here is another, classical way of reversing a String.</p>
                <h3>Cmd codes</h3>
                <ul>
                    <li><code class="highlighter-rouge">javac OrderClass.java</code> Compiles java code into a binary code.</li>
                    <li><code class="highlighter-rouge">java OrderClass</code> Executes binary code (Application).</li>
                </ul>
                <h3>Object Referencing Other Objects as a Property</h3>
                <table>
                    <tr>
                        <th>Customer</th>
                        <th>Clothing</th>
                    </tr>
                    <tr>
                        <td><pre><code>name
size
Clothing [] items</code></pre></td>
                        <td><pre><code>description
price</code></pre></td>
                    </tr>
                    <tr>
                        <td><pre><code>getName()
getSize()
getItems() {return items;}
inspectWardrobe()</code></pre></td>
                        <td><pre><code>gerPrice()</code></pre></td>
                    </tr>
                </table>
                <p>Access Clothing objects referenced by Customer</p>
                <pre><code>Customer customer01 = new Customer();
for (Clothing item: customer01.getItems()) {
    item.getPrice();
}</code></pre>
                <h3>References and Objects in Memory</h3>
                <p>There are two memory areas when the Java virtual machine starts: The <strong>Stack</strong>, which stores variables and values or pointers (an address of an objects) and the <strong>Heap</strong>, which stores objects.</p>
                <pre><code>Clothing[] items = {
    new Clothing(),
    new Clothing()
};</code></pre>
                <table>
                    <tr>
                        <th>Stack</th>
                        <th>Heap</th>
                    </tr>
                    <tr>
                        <td>
                            <table>
                                <tr>
                                    <td>total</td>
                                    <td>2.99</td>
                                </tr> 
                                <tr>
                                    <td>items</td>
                                    <td>0x01245</td>
                                </tr>
                            </table>
                        </td>
                        <td>
                            <nav>0x01245</nav>
                            <table>
                                <tr>
                                    <td>0</td>
                                    <td>0x12efa1</td>
                                </tr>
                                <tr>
                                    <td>1</td>
                                    <td>0xjf1123</td>
                                </tr>
                                <tr>
                                    <td>
                                        <nav>0x12efa1</nav>
                                        <table>
                                            <tr>
                                                <td>Socks</td>
                                            </tr>
                                            <tr>
                                                <td>0</td>
                                            </tr>
                                            <tr>
                                                <td>null</td>
                                            </tr>
                                        </table>
                                    </td>
                                    <td>
                                        <nav>0xjf1123</nav>
                                        <table>
                                            <tr>
                                                <td>Jacket</td>
                                            </tr>
                                            <tr>
                                                <td>15.5</td>
                                            </tr>
                                            <tr>
                                                <td>M</td>
                                            </tr>
                                        </table>
                                    </td>
                                </tr>
                            </table>
                        </td>
                    </tr>
                </table>
                <p><i>Note also that when it comes to the values reassignment, the new value gets assigned but not an address to object which holds it.</i></p>
                <p><i>Arrays are handled by an implicit Array object, therefore the array variable is an object reference.</i></p>
                <h3>Java Memory Management</h3>
                <h4>Java Memory Structure</h4>
                <div class="container_grid_common container_JMS">
                    <div style="background-color: inherit; grid-area: con-1;"></div>
                    <div style="font-style: italic; background-color: inherit; border-bottom: solid 1px rgb(51, 51, 51); padding: 0;  grid-area: con-3;">Stack area</div>
                    <div style="background-color: inherit;  grid-area: con-4;"></div>
                    <div style="background-color: rgb(127, 150, 190); grid-area: con-6;">Method Area</div>
                    <div style="background-color: rgb(163, 217, 230); grid-area: con-7;">Heap Area</div>
                    <div style="background-color: rgb(198, 183, 158); grid-area: con-8;">
                        <table>
                            <tr>
                                <td colspan="3">Thread 1</td>
                            </tr>
                            <tr>
                                <td colspan="3">Stack Frame</td>
                            </tr>
                            <tr>
                                <td>LVA</td>
                                <td>OS</td>
                                <td>FD</td>
                            </tr>
                        </table>
                    </div>
                    <div style="background-color: rgb(170, 230, 189); grid-area: con-9;">PC Register for Thread 1</div>
                    <div style="background-color: rgb(157, 193, 254); grid-area: con-10;">Native Method</div>
                </div>
                <ul>
                    <li><strong>Method Area</strong> stores superclass name, interface name and constructors.</li>
                    <li><strong>Heap memory</strong> - area of run time data, from which the dynamic memory for objects is dedicated. It can be accessed by any Thread/Stack.</li>
                    <li><strong>Stack area</strong> stores method specific values that are short-lived and are referenced to other objects in the heap.</li>
                    <li><strong>Stack frame</strong> Every frame  consist of own Local Variable Array (LVA), Frame Data (FD) and Operand Stack (OS). Only one frame is active in a Heap - current frame.</li>
                </ul>
                <h4>Garbage Collector</h4>
                    <p>Any object that is not accessible to any thread is considered dereferenced and becomes available for GC.</p>
                    <div class="container_grid_common container_GC">
                        <div style="background-color: inherit; grid-area: con-1;"></div>
                        <div style="font-style: italic; background-color: inherit; padding: 0; border-bottom: solid 1px rgb(51, 51, 51); grid-area: con-2;">Survivor Space</div>
                        <div style="background-color: inherit;  grid-area: con-3;"></div>
                        <div style="background-color: rgb(127, 150, 190); grid-area: con-4;">eden</div>
                        <div style="background-color: rgb(163, 217, 230); grid-area: con-5;">S0</div>
                        <div style="background-color: rgb(198, 183, 158); grid-area: con-6;">S1</div>
                        <div style="background-color: rgb(170, 230, 189); grid-area: con-7;">Tenured</div>
                        <div style="background-color: rgb(157, 193, 254); grid-area: con-8;">Permanent</div>
                        <div style="font-style: italic; background-color: inherit; border-top: solid 1px rgb(51, 51, 51); grid-area: con-9;">Young Generation</div>
                        <div style="font-style: italic; background-color: inherit; border-top: solid 1px rgb(51, 51, 51); grid-area: con-10;">Old Generation</div>
                        <div style="font-style: italic; background-color: inherit; border-top: solid 1px rgb(51, 51, 51); grid-area: con-11;">Metaspace</div>
                    </div>
                    <ol>
                        <li><strong>Young Generation</strong> - all new objects. A minor GC occurs here.</li>
                        <li><strong>Tenured Generation</strong> - long surviving objects.</li>
                        <li><strong>Metaspace</strong> Stores static data, which is accessible anytime.</li>
                    </ol>
                <h4>Java Volatile Keyword</h4>
                <p>The Java volatile keyword is used to mark a Java variable as "being stored in main memory" (RAM). Every write to a volatile variable will be written to main memory, and not just to the CPU registers. E.g.:</p>
                <pre><code>public <strong>volatile</strong> int counter = 0;</code></pre>
                <p>Declaring a variable volatile thus guarantees the visibility for other threads of writes to that variable.</p>
                <p><em>if two threads are both reading and writing to a shared variable, then using the volatile keyword for that is not enough.</em> You need to use a synchronized in that case to guarantee that the reading and writing of the variable is atomic. Reading or writing a volatile variable does not block threads reading or writing. For this to happen you must use the synchronized keyword around critical sections.</p>
                <p>As an alternative to a synchronized block you could also use one of the many atomic data types found in the java.util.concurrent package. For instance, the AtomicLong or AtomicReference or one of the others.</p>
                <p>In case only one thread reads and writes the value of a volatile variable and other threads only read the variable, then the reading threads are guaranteed to see the latest value written to the volatile variable. Without making the variable volatile, this would not be guaranteed.</p>
                <h4>Java Synchronized Blocks</h4>
                <p>A Java synchronized block marks a method or a block of code as synchronized. A synchronized block in Java can only be executed a single thread at a time (depending on how you use it). Java synchronized blocks can thus be used to avoid <strong>race condition</strong>.</p>
                <p>If two or more threads share an object, and more than one thread updates variables in that shared object, <strong>race conditions</strong> may occur.</p>
<pre><code>public <strong>synchronized</strong> void add(int value){
    this.count += value;
}</code></pre>
                <h3>Initializing Object Using the Constructor Method</h3>
                <pre><code>public class Clothing {
    private String description;
    public double price;
    public Clothing () {
    } // "no-argument do-nothing Constructor" needed to be added as soon as parameterized constructor is added.

    public Clothing (String description, double price) {
        this.description = description;
        this.price = price;
    } // Another Constructor
    /* remaining methods */
}</code></pre>
                <p>Initialize an object</p>
                <pre><code>public static void main (String[] args) {
    Clothing item = <strong>new Clothing ();</strong>
    // invoke set methods for item1 to initialize data
    Clothing item = <strong>new Clothing ("Jacket", 20.99, "M");</strong>
    // item2 is already initialized
}</code></pre>
                <h3>Static Methods</h3>
                <p>It is a e.g. a <strong>static variable value</strong> that is shared by all objects of a class. Or it can be a <code class="highlighter-rouge">public static void filter(Database data){...}</code> method of a class, which you want to execute some process to perform an action.</p>
                <ul>
                    <li>Is <i>not specific</i> to any object instance</li>
                    <li>Can be accessed without instantiating the class (<code class="highlighter-rouge">new</code>), e.g. <code class="highlighter-rouge">Math.random()</code>.</li>
                    <li>Static variables sees only other static variables, therefor can not access instance (internal) variables.</li>
                    <li>Can not be overridden by other classes.</li>
                </ul>
                <h3>Handling Exceptions - the <code class="highlighter-rouge">try/catch</code> Block</h3>
                <pre><code><strong>try {</strong>
    Clothing[] items = new Clothing[10];
    items[0].description = "Pink Boiler Suit";
<strong>}   catch (NullPointerException e) {</strong>
    String errMsg = e.getMessage();
    e.printStackTrace();
<strong>}   catch (Expectation e) { ... }</strong></code></pre>
                <ul>
                    <li><code class="highlighter-rouge">try</code> block contains logic that can potentially result in expectations.</li>
                    <li><code class="highlighter-rouge">catch</code> block contain logic that handles expectations.</li>
                </ul>
                <h3>Object-Oriented Approach to Code Reuse</h3>
                <h3>Inheritance</h3>
                <p>We create a Class "Gadget" for Subclasses "Camera()" and "TV()", which is called a Superclass.</p>
                <p>Super class stores common attributes and behavers, subclasses however may overwrite them and have more specific execution.</p>
                <p>Hoverer, "Gadget" Superclass can not have is record a video method and change a chanel, because it will be not common for all Gadgets.</p>
                <p>There could be any number of levels in the hierarchy, from very general to very specific child types.</p>
                <p>Sometimes, inheritance is unwelcome. Therefore, classes which must not be extended are marked with a <code>final</code> access modifier. E.g. <code>public final class Animal {...}</code></p>
                <p>Object is the top-level class in a Java class hierarchy.</p>
                <div>                    
                    <pre><code>public static void main(String[] args) {
    Clothing[] items = new Clothing[2];
    items[0] = new Tailored();
    items[1] = new Standard();
    for (Clothing item: items) {
        item.getPrice();
    }
}</code></pre>
                    <pre><code>public class Clothing extends Object { // No need to specify extend Object words here for the SuperClass
    private double price;
    public double getPrice() {
        return price;
    }
}</code></pre>
                    <p>The code below override common behaver.</p>
                    <pre><code>public class Tailored <strong>extends</strong> Clothing { // The extend word here is mandatory
    private double fee;
    @Override
    public double getPrice() {
        return super.getPrice() + fee;
    }
}</code></pre>
                </div>
                <p>A method in a subclass must have exactly the same name, return type, and parameters as the method in the parent class, that is, the method signature. If they do not match, the method will not be overridden.</p>
                <p>The access level cannot be more restrictive in the subclass. For example, if a method in the parent class is public, the overridden method in the subclass cannot be private or protected.</p>
                    <h4>Inheritance level</h4>
                        <ul>
                            <li>Single</li>
                            <li>Multi</li>
                            <li>Hierarchical</li>
                            <li>Multiple/Hybrid/Diamond - is not allowed in Java, but can be achieved by Interfaces</li>
                        </ul>
                <h3>Abstract abd Interface classes - common behaver</h3>
                    <p>There are several common principles between abstract and</p>
                    <ul>
                        <li>Both classes cannot be directly instantiated (creating new instances of objects to be used in a program), if it is marked with the Abstract/Interface keyword.</li>
                        <li>The Abstract/Interface classes` purpose is to be extended by one or more concrete subclasses.</li>
                        <li>A subclass derived from an Abstract/Interface class must either implement all the base class’s abstract methods or be abstract itself.</li>
                    </ul>
                <h3>Define Abstract Classes & Methods</h3>
                <p>The Abstract keyword can be used to encourage class extensibility. It is vise versa to Inheritance method. Is used when there is no shared pice of code whatsoever and all subclasses uses their uniq execution. So that is to provide a design and polymorphism.</p>
                <ul>
                    <li>Class cannot be directly instantiated (creating new instances of objects to be used in a program), if it is marked with the abstract keyword.</li>
                    <li>The abstract class purpose is to be extended by one or more concrete subclasses.</li>
                    <li>The abstract methods describe method signatures without a method body.</li>
                    <li>An abstract class can declare both abstract and concrete methods.</li>
                    <li>If a class defines one or more abstract methods, then the class itself must be declared abstract.</li>
                    <li>A subclass derived from an abstract class must either implement all the base class’s abstract methods or be abstract itself.</li>
                    <li>A sub-class can inherit only one abstract class.</li>
                </ul>
                <pre><code>public <strong>abstract</strong> class Clothing {
    public <strong>abstract</strong> double refund();
    void changeColor() {
        System.out.println("Color is green");
    }
}
// A sub-class MUST override all abstract methods
// of the abstract class;
// A sub-class MAY override all non-abstract methods
// of an abstract class.</code></pre>
                <pre><code>public class <strong>Tailored</strong> extends Closing {
    // MUST be overridden
    Public double refound() {
        <strong>Return 0;</strong>
    }
    // MAY be overridden
    @Override
    void changeColor() {
        System.out.println("Color is red");
    }
}</code></pre>
                <pre><code>public class <strong>Standard</strong> extends Clothing {
    public double refund() {
        // MUST be overridden
        <strong>return getPrice();</strong>

        // Private method of this class that is NOT overridden
        void addPrice() {
            System.out.println("Price is 30 $");
        }
    }
}</code></pre>
                
                <pre style="color: rgb(246, 69, 69);"><code><strong>Clothing</strong> jacket1 = new <strong>Clothing</strong>();</code></pre>
                <p>Abstract classes can be used to create references to objects.</p>
                <pre style="color: green;"><code><strong>Clothing[]</strong> items = new <strong>Clothing</strong>[3];</code></pre>
                <pre><code><strong>Clothing</strong> jacket2 = new <strong>Tailored</strong>();
jacket2.refund();
jacket2.changeColor(); // "Color is red"</code></pre>
                <pre><code><strong>Clothing</strong> jacket3 = new <strong>Standard</strong>();
jacket3.refund();
jacket3.changeColor(); // "Color is green."
// ERROR
// addPrice() method does not exist in Clothing.
// jacket3.addPrice();
// Then we need to:</code></pre>
                <pre><code><strong>Standard</strong> jacket4 = new <strong>Standard</strong>();
jacket4.refund();
jacket4.addPrice();</code></pre>
                <h3>Java Interfaces</h3>
                <p>An interface defines a set of features that can be applied to various other classes.</p>
                <ul>
                    <li>Instance methods are by default public, static and abstract.</li>
                    <li>Class cannot be directly instantiated, if it is marked with the Interface keyword.</li>
                    <li>They can contain concrete methods, but only if the methods are either <code class="highlighter-rouge">default</code>, <code class="highlighter-rouge">private</code>, or <code class="highlighter-rouge">static</code>. In case of <code class="highlighter-rouge">default</code> this means that, the classes which implements this interface can not inherit its methods. You can access Interface methods by calling them directly.</li>
                    <li>They can contain constants but not variables.</li>
                    <li>
                        By default, constants are MARKED AS <code class="highlighter-rouge">public static final</code> and constants can be used in an implementation class WITHOUT an interface name prefix.
                        <em>Note that, IF by coincidence the name of a class variable/constant matches a constant defined in an implemented interface, the local class variable/constant overrides the interface constant. The constant is converted to a variable and can be changed as many times as desired.</em>
                    </li>
                </ul>
                <pre><code>public <strong>interface</strong> Recyclable {
    // A Constant in the Interface
    String MEASURE = "meter";            
    <strong>void recycle();</strong>
}</code></pre>
                <pre><code>public class Clothing <strong>implements</strong> Recyclable {
    // Use of the constant
    // without an interact prefix "Recyclable."
    String measure = MEASURE;

    // The compiler will now require that method recycle
    // be implemented. Compilation will fail if this
    // method is missing from this class.
    <strong>public void recycle() {
        /* clothing specific implementation */
    }</strong>
}</code></pre>
                <pre><code>public class Bottle <strong>implements</strong> Recyclable {
    <strong>public void recycle() {
        /* bottle specific implementation */
    }</strong>
}</code></pre>
                <p><strong>Notes</strong>: Interface resembles an abstract class, except no variables or regular concrete methods are allowed.</p>
                <h4>Implement Interfaces</h4>
                <ul>
                    <li>Object-oriented inheritance is not flexible.</li>
                    <li>
                        Depending on the point of view, a given class may require different parents (to be of more than one type.)
                        <pre><code>public class ColorCircle extends Circle implements Shape {
    ...
}</code></pre>
                    </li>
                    <li>Different features can be defined by different interfaces.</li>
                    <li>
                        A class can implement as many interfaces as required.
                        <pre><code>public class Clothing <strong>implements</strong> Recyclable, Comparable {
    <strong>public void recycle() { ... }
    public int void compareTo(Object other) { ... }</strong>
}</code></pre>
                    </li>
                    <li>
                        It is also possible for an interface(s) to inherit (extend) from an interface. And then even another class can implement the extended interface.
                        <pre><code>public interface ProductC extends ProductA, ProductB {
    void getProductCInfo();
}</code></pre>
                    </li>
                </ul>
                <h3>Enums</h3>
                <p><code class="highlighter-rouge"></code></p>
                <h3>Java Classes</h3>
                <h4>Classes-Wrappers</h4>
                <p>Classes-Wrappers are used to transform primitive data into an Object.</p>
<pre><code>int num = 55;
String strByte = "25"

// Convert a primitive or a String into an Object
Integer obj = Integer.valueOf(num); 
Integer obj1 = Integer.valueOf(strByte); 

// Convert an Object or a String to primitive
int var01 = obj.intValue();
int var02 = Integer.parseInt(strByte);</code></pre>
                <h4>Scanner for cmd line input</h4>
<pre><code>Scanner scanner = new Scanner(System.in);
String strA = scanner.nextLine();
int input = Integer.parseInt(scanner.nextLine());</code></pre>
                <h4>ArrayList</h4>
                <p>The <code class="highlighter-rouge">ArrayList</code> class is a resizable array. Elements in an ArrayList are actually objects. To use other types, such as int, you must specify an equivalent wrapper class, e.g.: <code class="highlighter-rouge">Integer</code>.</p>
                <p>The difference between a built-in array and an <code class="highlighter-rouge">ArrayList</code> in Java, is that the size of an array cannot be modified (if you want to add or remove elements to/from an array, you have to create a new one). While elements can be added and removed from an <code class="highlighter-rouge">ArrayList</code> whenever you want.</p>
<pre><code>Character a = 'a';
ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();
list.add(a);
// Access an item by the collection index
list.get(0);
// Change an item
list.set(0, "b");
// Remove an item or all the elements
list.remove(0);
list.clear();

list.size();
</code></pre>
                <h4>Collections</h4>
                <p>The <code class="highlighter-rouge">Collections</code> class has a useful <code class="highlighter-rouge">sort()</code> method</p>
<pre><code>Collections.sort(list);</code></pre>
                <section>
                <h2 class="section">Links to helpful websites</h2>
                <ul>
                    <li><a href="https://jenkov.com/tutorials/java-concurrency/java-memory-model.html">The Java Memory Model And The Hardware Memory Architecture</a></li>
                    <li><a href="https://jenkov.com/tutorials/java-concurrency/volatile.html">Java Volatile Keyword</a></li>
                </ul>
            </section>
            <section>
                <h2 class="section">Questions which I have got</h2>
            </section>
        </div>
        <ul class="sticky-element">
            <li class="left-tiem">
                <a href="../20/index.html">
                    <button class="arrow">
                        <span class="arrow-previous"></span>
                    </button>
                </a>
            </li>
            <li class="right-tiem">
                <a href="../22/index.html">
                    <button class="arrow">
                        <span class="arrow-next"></span>
                    </button>
                </a>
            </li>
        </ul>
    </main>
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
</body>

</html>