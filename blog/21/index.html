<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="witdh=device-witdh, initial-scale=1.0">
    <title>Twentieth First - Web Portfolio of Denys</title>
    <link rel="stylesheet" type="text/css" href="../../main.css">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    
</head>

<body>
    <header>
        <ul class="navigation">
            <li class="navigation-item"><a class="item-link" href="../../index.html">Home</a></li>
            <li class="navigation-item"><a class="item-link" href="../../blog/index.html">Blog</a></li>
            <li class="navigation-item"><a class="item-link" href="../../projects/index.html">Projects</a></li>
            <li class="navigation-item"><a class="item-link" href="../../contact/index.html">Contact</a></li>
        </ul>
    </header>
    <main>
        <h1 class="title">Java</h1>
        <p class="left date">January 19, 2025</p>
        <div class="block left">
            <section>
                <h2>Variable initialization - additional character</h2>
                    <ul>
                        <li><code>byte a = 10;</code> 8 bit. Range from -128 to 127;</li>
                        <li><code>short s = 10000;</code> 16 bit. Range from -32768 to 32767;</li>
                        <li><code>int cost = 133_452_667</code> Range from -2,147,483,684 to 2,147,483,647. <code>_</code> is for readability;</li>
                        <li><code>long <i>a</i> = 123125415l or L;</code></li>
                        <li><code>float <i>b</i> = 2.1E12f or F;</code></li>
                        <li><code>boolean <i>c</i> = !(x > 5 && x < 10);</code></li>
                        <li><code>String <i>d</i> = new String(arrayName);</code></li>
                        <li><code>double price1 = 9.99, price2 = 12.99;</code></li>
                    </ul>
                    <p>If uninitialized, variables have a default value:</p>
                    <ul>
                        <li><code>int</code>: <strong>0</strong></li>
                        <li><code>String</code>: <strong>null</strong></li>
                        <li><code>boolean</code>: <strong>false</strong></li>
                    </ul>
                    <h3>Constants</h3>
                    <p>Use <code>final</code> word before initialization of a variable.</p>
                <h2>Theory</h2>
                    <p>Classes consist of methods and data; Packages - folder where the class will be saved;</p>
                    <p>Classes are Templates (they are singles), Objects are Individual elements created from classes.</p>
                    <p>Encapsulation - definition of methods instead of using direct access to the variables.</p>
                    <p>Polymorphism - allows use of sub-classes` objects as object of parent. It allows a single method to interact with object from different classes.</p>
                    <p>Abstractions - defines general characteristics of objects, ignoring details of their realization. It is a compelling reason to use abstract classes, as long as the “is-a” relationship is preserved.</p>
                        <ul>
                            <li>A class can extend only one Abstraction.</li>
                        </ul>
                    <p>Interfaces - defines some function, which does not have concrete realization, which is then implemented by classes which use this interfaces.</p>
                    <p>Methods form the object's interface with the outside world; the buttons on the front of your television set, for example, are the interface between you and the electrical wiring on the other side of its plastic casing. You press the "power" button to turn the television on and off.</p>
                        <ul>
                            <li>Describes the behaver, but not a type.</li>
                            <li>The access modifiers are not specified.</li>
                        </ul>
                    <p>Override of methods - change of the functional in a sub-class, if a sub-class has the same method, which is defined in a parent class (super class).</p>
                    <p>If variables contain the same value, the value memory address is the same. However, if <code>new</code> keyword is used, new value will be created. But, interning rows involves storing only ONE copy, e.g.:</p>
<pre><code>String product5 = new String("Round cube").intern();</code></pre>
                    <p><strong>Resources</strong> - an Object which needs to be closed after end of the work with a program.</p>
                <h2>Data Conversion</h2>
                <p>Downgrade of a type is possible only with explicit conversion, e.g. int into a char.</p>
<pre><code>int a = 128;
long b = a; // Implicit Type Data conversion
long b = (long) a; // Explicit Type Data Conversion</code></pre>
                <h2>Escape characters</h2>
                <table>
                    <thead>
                        <tr>
                            <th>Esc. Char</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>\\</td>
                            <td>Translated into a single \ character in the String</td>
                        </tr>
                        <tr>
                            <td>\t</td>
                            <td>Translated into a single tab character in the string</td>
                        </tr>
                        <tr>
                            <td>\r</td>
                            <td>Translated into a single carriage return character in the string</td>
                        </tr>
                        <tr>
                            <td>\n</td>
                            <td>Translated into a single new line character in the string</td>
                        </tr>
                    </tbody>
                </table>
                <h2>Mandatory code</h2>
                    <pre><code>public class nameOfTheFile {
    public static void main(String[] args) {
- Classes goes here}
}</code></pre>
                <h2>Classes initialization and usage</h2>
                    <p>new Classes need to be in another <code>.java</code> file. <i>This information needs to be confirmed.</i></p>
                    <pre><code>public class Customer {
    - data (called fields);
    String name;
    String size = "S";
    - Operations (called methods);
    void setSize (String newSize) {
        size = newSize;
    }
    String getSize() {
        return size;
    }                         
}</code></pre>
                    <p>Then use the class in methods of other classes</p>
                    <pre><code>Customer person1 = new Customer();
    person1.name = "Bob";
    System.out.println(person1.name);</code></pre>
                <h2>Methods initialization</h2>
                    <pre><code>&lt;access modifier&gt; &lt;return type&gt; &lt;method name&gt; (&lt;parameter list&gt;) {
    /* method body */
    /* return statement */
}</code></pre>
                    <pre><code>public static double <i>subtract</i>(int a, int b, String...params) {
    int result = a - b;
    return (double) result;
}

int subResult = subtract(10, 5); // the method call</code></pre>
                    <p>This method consist of the following parts:</p>
                    <ul>
                        <li><code>public static</code> - modification</li>
                        <li><code>double</code> - type of the result that is returned</li>
                        <li><code>subtract</code> - method name</li>
                        <li><code>int a, int b, String...params</code> - input. Type...params - can receive as many such parameters as needed.</li>
                        <li><code>return (double) result</code> - if a method is a void, than write just <code>return;</code></li>
                    </ul>
                    <p>Name of methods should begin with a verb and written in lowerCamelCase.</p>
                    <h2>Access Modifiers</h2>
                    <table>
                        <tr>
                            <th>Access Modifier</th>
                            <th>Visibility Scope</th>
                        </tr>
                        <tr>
                            <td><code>public</code></td>
                            <td>All classes</td>
                        </tr>
                        <tr>
                            <td><code>protected</code></td>
                            <td>Classes in the same package and subclasses.<br>This is true even if the subclass is not located in the same package as the superclass.</td>
                        </tr>
                        <tr>
                            <td>default (no access modifier)</td>
                            <td>Classes in the same package</td>
                        </tr>
                        <tr>
                            <td><code>private</code></td>
                            <td>Some Classes</td>
                        </tr>
                    </table>
                    <p><i>Note that classes can only be either default or public.</i></p>
                    <h2>Encapsulation</h2>
                    <p>Hiding variables and allowing access to data through Methods only is called <strong>Encapsulation</strong>.</p>
                    <h2>Using Method overloading</h2>
                    <p>Class can define several methods that:</p>
                    <ul>
                        <li>Have the same name</li>
                        <li>Have different signatures</li>
                            <ul>
                                <li>The <strong>number</strong> of parameters</li>
                                <li>The <strong>types</strong> of parameters</li>
                            </ul>
                    </ul>
                    <p>Overloading is convenient for invokers.</p>
                    <pre><code>public class Clothing {
    public boolean fit(int size) {...}
    public boolean fit(String size) {...}
    public boolean fit(int height, int witdh) {...}
}</code></pre>
                <h2>Variable Shadowing</h2>
                <pre><code>public class Clothing {
    double <strong>price</strong>;
    public void setPrice(String <strong style="color: red;">price</strong>) {
        <strong>this.price</strong> = <strong style="color: red;">price</strong>;
    }
}</code></pre>
                <h2>Package initialization</h2>
                    <pre><code>package duke.choice;</code></pre>
                    <p><code>duke</code> - is the main folder; <code>choice</code> - is a subfolder.</p>
                <h2>Switch Statement</h2>
                <pre><code>... String condition = "Used";
    switch (condition) {
    case "Damaged", "Returned":
        discount = price * 0.1;
        break;
    case "Used":
        discount = price * 0.2;
        break;
    default:
        discount = price;
                </code></pre>
                <h2>Array</h2>
                <pre><code>int[] numbers = {1, 2, 3};
int numbers[] = {1, 2, 3};

for (int i = 0; i < numbers.length; i++) {
    System.out.println(numbers[i]);
}

for (int number : numbers) {
    System.out.println(number);
}</code></pre>
                <p>Loops are running until an expression is false.</p>
                <pre><code>int[] numbers = new int[4];</code></pre>
                <p>In this case an empty array of length of 4 is created.</p>
                <pre><code>String name = "Bob";
char[] chars = name.toCharArray();
chars[0]; // = 'B'
String newName = new String(chars);</code></pre>
                <p>Transformation of string into array of characters and vice versa.</p>
                <pre><code>import java.until.Arrays;
String toString = Arrays.toString(numbers);</code></pre>
                <p>Transforms the array into a string.</p>
                <pre><code>String[] nameParts = fullName.split(" ");</code></pre>
                <p>Splits a string onto parts based on character</p>
                <h2>String Methods</h2>
                <ul>
                    <li><code>String upperCaseName = newName.toUpperCase();</code></li>
                    <li><code>String lowerCaseName = newName.toLowerCase();</code></li>
                    <li><code>String isEmpty = newName.isEmpty();</code> Sees space</li>
                    <li><code>String isEmpty = newName.isBlank();</code> Does`t sees space</li>
                    <li><code>String substring = newName.substring(1, 2);</code> beginIndex (including) and endIndex (excluding), where the String will be cut.</li>
                    <li><code>int indexOf = newName.indexOf('=');</code> find an index of a specific char or sequence of characters.</li>
                    <li><code>char charAtIndexOne = newName.charAt(1);</code> 'o' at index 1.</li>
                    <li><code>String stringLength = String.length();</code> It is different to .length, which works on arrays.</li>
                    <li><code>String trim = " How ".trim()</code> Eliminates spaces.</li>
                    <li><code>String numberValue = String.valueOf(10);</code> It can handle converting boolean, char, char array, double, float, int, long, and Object types into their respective string representations.</li>
                    <li><code>String equals = newName.equals("Bob");</code> Object types are compared by <code>equals()</code> method. Primitive by <code>==</code>. There is also a <code>equalsIgnoreCase()</code> method.</li>
                    <li><code>int compare = name.compareTo("Bob");</code> The comparison is based on the Unicode value of each character in the strings. The method returns 0 if the string is equal to the other string. A value less than 0 is returned if the string is less than the other string (less characters) and a value greater than 0 if the string is greater than the other string (more characters). There is also a <code>CompareToIgnoreCase()</code></li>
                    <li>
                        <code>boolean regionMatches = name.regionMatches(boolean ignoreCase, int offset, String other, int otherOffset, int length);</code>
<pre><code>String myStr1 = "Hello, World!";
String myStr2 = "New World";
boolean regionMatches = name.regionMatches(7, myStr2, 4, 5); // True</code></pre>
                    </li>
                    <li><code>String contains = name.contains("ob");</code> Returns a boolean on a consequent of characters in a given array.</li>
                    <li><code>String concat = newName.concat(previousName);</code> Or use <code>+</code>`s.</li>
                    <li><code>String join = String.join(name, "", " goes to bed ", " launches Rockets");</code> Places delimiter between elements.</li>
                    <li><code>String replace = name.replace("Bo", "C");</code> or <code>name.replaceFirst(stringVar, "c");</code></li>
                    <li><code>boolean startsWith = name.startsWith("b", 2);</code> 2 is optional, indicates starting index number.</li>
                    <li><code>boolean endsWith = name.endsWith("b");</code></li>
                    <li><code>String[] split = name.split("o", 1);</code> 1 - number of elements which will be returned</li>
                    <li><code>String repeat = name.repeat(4);</code> repeats name *4 times;</li>
                    <li><code>String format = String.format("%2$,3.2f %1$s", "meters", 1260.5052);</code> Formats a string using placeholders and parameters</li>
                    <li>
                        <code>String format = strVar.formatted(name, salary); String strVar = "%s receives CHF %.2f";</code>. The difference compared to <code>String.format()</code> is in passing the ready string.
                        <h3>Placeholders</h3>
                        <p><code>%[arg$][flags][width][.precision]conversion</code>. The components in [square brackets] are optional.</p>
                        <ul>
                            <li><code>arg$</code> A number followed by a $ sign which indicates which of the additional arguments to use, argument numbers start at 1. This can be replaced with a <code>&lt;</code> which specifies that the argument from the previous placeholder should be used.</li>
                            <li><code>flags</code> A sequence of any of the following characters:
                              <ul>
                                <li><code>-</code> - Makes the output left-justified by adding any padding spaces to the right instead of to the left.</li>
                                <li><code>#</code> - Shows an alternate representation of the formatted data depending on the conversion.</li>
                                <li><code>+</code> - Causes positive numbers to always be prefixed with "+".</li>
                                <li><code> </code> - (A space character) This prefixes a space to positive numbers, primarily so that the digits can be lined up with the digits of negative numbers.</li>
                                <li><code>0</code> - Pads numbers with zeroes on the left.</li>
                                <li><code>,</code> - Groups digits (for example by thousands) and puts separators between the groups. This is affected by the locale.</li>
                                <li><code>(</code> - Encloses negative numbers in parentheses.</li>
                              </ul>
                            </li>
                            <li><code>width</code> A whole number specifying the minimum number of characters that the output should occupy. If necessary spaces are added to the right to reach this number, or to the left if the <code>-</code> flag is used.</li>
                            <li><code>.precision</code> A <code>.</code> followed by a whole number indicating how many decimal digits to show in the formatted data.</li>
                            <li><code>conversion</code> A character which indicates how an argument's data should be represented. If the character is uppercase the data will be formatted in uppercase where possible. The list of possible characters is shown in the table below.</li>
                          </ul>
                        <h3>List of conversions</h3>
                        <table>
                            <tr>
                                <th>Specifier</th>
                                <th>Meaning</th>
                            </tr>
                            <tr>
                                <td>%s or %S</td>
                                <td>String</td>
                            </tr>
                            <tr>
                                <td>%d</td>
                                <td>integer: byte, short, int, long</td>
                            </tr>
                            <tr>
                                <td>%f</td>
                                <td>real number: float, double</td>
                            </tr>
                            <tr>
                                <td>%b or %B</td>
                                <td>boolean</td>
                            </tr>
                            <tr>
                                <td>%c or %C</td>
                                <td>char</td>
                            </tr>
                            <tr>
                                <td>%t or %T</td>
                                <td>Date</td>
                            </tr>
                            <tr>
                                <td>%%</td>
                                <td>displays % character</td>
                            </tr>
                            <tr>
                                <td>%n</td>
                                <td>Line break</td>
                            </tr>
                            <tr>
                                <td>%.2f</td>
                                <td>number of decimal points after coma</td>
                            </tr>
                        </table>
                    </li>
                </ul>
                <h2>Formatter class</h2>
                <p>Works the same as <code>String.format()</code></p>
<pre><code>String[] products = new String[] {"orange", "apple", "mango", "kiwi"};
StringBuilder builder = new StringBuilder();
Formatter formatter = new Formatter(builder);
int count = 0;

formatter.format("List for %tD %tT:%n",
        LocalDate.now(), LocalTime.now());

for (String item : products) {
    count++;
    builder.append(count).append(") ")
            .append(item).append("\n");
}

System.out.println(builder);</code></pre>
                <h2>printf</h2>
                <code>System.out.printf("1) User: %s %s, email: %s%n", firstName, lastName, email);</code>
                <h2>DecimalFormat class</h2>
<pre><code>String strCost1 = new DecimalFormat("0.00").format(cost1);
System.out.println("2) Non-rounded is " + cost1 + ", rounded is " + strCost1);

String strCost2 = new DecimalFormat("#.##", new DecimalFormatSymbols(Locale.ENGLISH)).format(cost);
System.out.println("3) Non-rounded is " + cost + ", rounded is " + strCost2);</code></pre>
                <h2>Random class</h2>
<pre><code>Random random = new Random();

String generatedString = random.ints(leftLimit, rightLimit + 1)
    .filter(i -> (i <= 57 || i >= 65) && (i <= 90 || i >= 97))
    .limit(targetStringLength)
    .collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append)
    .toString();</code></pre>
                <h2>StringBuilder class</h2>
<pre><code>StringBuilder builder = new StringBuilder();
builder.append("hello").append("world").append(31);

builder.reverse();
String reverseString = builder.toString();</code></pre>
                                <p>The advantage of a string builder to simple concatenation is that it creates only one String in memory during appending. Less memory usage.</p>
<pre><code>String result = new String();
char[] reverses = input.toCharArray();
for (int i = reverses.length-1; i >= 0; i--) {
result += reverses[i];
}</code></pre>
                                <p>Here is another, classical way of reversing a String.</p>
                                <h2>String buffer class</h2>
                                <p>StringBuffer is synchronized. This means that multiple threads cannot call the methods of StringBuffer simultaneously. StringBuilder is asynchronized.</p>
                                <h3>StringBuffer / StringBuilder Methods</h3>
                                <ul>
                                    <li><code>obj.append(var or "")</code></li>
                                    <li><code>obj.insert(2,"App")</code> At a position</li>
                                    <li><code>obj.replace(2,4,"App")</code> Starting and ending at</li>
                                    <li><code>obj.delete(2, 4)</code> Starting and ending at</li>
                                </ul>
                                <h2>StringJoiner class</h2>
                                <p>Is used to join Strings.</p>
                                <h3>StringJoiner Constructor</h3>
                                <code>StringJoiner(CharSequence delimiter, CharSequence prefix, CharSequence suffix)</code>
                                <h3>StringJoiner Methods</h3>
                                <ul>
                                    <li><code>obj.add("String")</code> adds a String</li>
                                    <li><code>obj.merge(StringJoiner other)</code> Merges two StringJoiners</li>
                                </ul>
<pre><code>private final static String PREFIX = "[";
private final static String SUFFIX = "]";
StringJoiner joiner = new StringJoiner(", ", PREFIX, SUFFIX);
joiner.add("orange").add("palm");
// RESULT: [orange, palm]
StringJoiner vegesJoiner = new StringJoiner("-", PREFIX, SUFFIX);
vegesJoiner.add("potato").add("carrot");
StringJoiner mergedJoiner = joiner.merge(vegesJoiner);
// RESULT: [orange, palm, potato-carrot]</code></pre>
                <h2>Character Methods</h2>
                <ul>
                    <li><code>char lowerCase = Character.toLowerCase(name);</code> or <code>toUpperCase();</code></li>
                    <li><code>char a = (char) 82;</code> Changes number to a relevant character.</li>
                    <li><code>boolean isLetter = Character.isLetter('A');</code></li>
                    <li><code>boolean isDigit = Character.isDigit(2);</code></li>
                    <li><code>boolean isWSp = Character.isWhitespace('\t');</code> Prints true.</li>
                    <li><code>boolean isUCase = Character.isUpperCase('A');</code> or <code>isLowerCase();</code></li>
                </ul>
                <h2>Cmd codes</h2>
                <ul>
                    <li><code>javac OrderClass.java</code> Compiles java code into a binary code.</li>
                    <li><code>java OrderClass</code> Executes binary code (Application).</li>
                </ul>
                <h2>Object Referencing Other Objects as a Property</h2>
                <table>
                    <tr>
                        <th>Customer</th>
                        <th>Clothing</th>
                    </tr>
                    <tr>
                        <td><pre><code>name
size
Clothing [] items</code></pre></td>
                        <td><pre><code>description
price</code></pre></td>
                    </tr>
                    <tr>
                        <td><pre><code>getName()
getSize()
getItems() {return items;}
inspectWardrobe()</code></pre></td>
                        <td><pre><code>gerPrice()</code></pre></td>
                    </tr>
                </table>
                <p>Access Clothing objects referenced by Customer</p>
                <pre><code>Customer customer01 = new Customer();
for (Clothing item: customer01.getItems()) {
    item.getPrice();
}</code></pre>
                <h2>References and Objects in Memory</h2>
                <p>There are two memory areas when the Java virtual machine starts: The <strong>Stack</strong>, which stores variables and values or pointers (an address of an objects) and the <strong>Heap</strong>, which stores objects.</p>
                <pre><code>Clothing[] items = {
    new Clothing(),
    new Clothing()
};</code></pre>
                <table>
                    <tr>
                        <th>Stack</th>
                        <th>Heap</th>
                    </tr>
                    <tr>
                        <td>
                            <table>
                                <tr>
                                    <td>total</td>
                                    <td>2.99</td>
                                </tr> 
                                <tr>
                                    <td>items</td>
                                    <td>0x01245</td>
                                </tr>
                            </table>
                        </td>
                        <td>
                            <nav>0x01245</nav>
                            <table>
                                <tr>
                                    <td>0</td>
                                    <td>0x12efa1</td>
                                </tr>
                                <tr>
                                    <td>1</td>
                                    <td>0xjf1123</td>
                                </tr>
                                <tr>
                                    <td>
                                        <nav>0x12efa1</nav>
                                        <table>
                                            <tr>
                                                <td>Socks</td>
                                            </tr>
                                            <tr>
                                                <td>0</td>
                                            </tr>
                                            <tr>
                                                <td>null</td>
                                            </tr>
                                        </table>
                                    </td>
                                    <td>
                                        <nav>0xjf1123</nav>
                                        <table>
                                            <tr>
                                                <td>Jacket</td>
                                            </tr>
                                            <tr>
                                                <td>15.5</td>
                                            </tr>
                                            <tr>
                                                <td>M</td>
                                            </tr>
                                        </table>
                                    </td>
                                </tr>
                            </table>
                        </td>
                    </tr>
                </table>
                <p><i>Note also that when it comes to the values reassignment, the new value gets assigned but not an address to object which holds it.</i></p>
                <p><i>Arrays are handled by an implicit Array object, therefore the array variable is an object reference.</i></p>
                <h2>Java Memory Management</h2>
                <h3>Java Memory Structure</h3>
                <div class="container_grid_common container_JMS">
                    <div style="background-color: inherit; grid-area: con-1;"></div>
                    <div style="font-style: italic; background-color: inherit; border-bottom: solid 1px rgb(51, 51, 51); padding: 0;  grid-area: con-3;">Stack area</div>
                    <div style="background-color: inherit;  grid-area: con-4;"></div>
                    <div style="background-color: rgb(127, 150, 190); grid-area: con-6;">Method Area</div>
                    <div style="background-color: rgb(163, 217, 230); grid-area: con-7;">Heap Area</div>
                    <div style="background-color: rgb(198, 183, 158); grid-area: con-8;">
                        <table>
                            <tr>
                                <td colspan="3">Thread 1</td>
                            </tr>
                            <tr>
                                <td colspan="3">Stack Frame</td>
                            </tr>
                            <tr>
                                <td>LVA</td>
                                <td>OS</td>
                                <td>FD</td>
                            </tr>
                        </table>
                    </div>
                    <div style="background-color: rgb(170, 230, 189); grid-area: con-9;">PC Register for Thread 1</div>
                    <div style="background-color: rgb(157, 193, 254); grid-area: con-10;">Native Method</div>
                </div>
                <ul>
                    <li><strong>Method Area</strong> stores superclass name, interface name and constructors.</li>
                    <li><strong>Heap memory</strong> - area of run time data, from which the dynamic memory for objects is dedicated. It can be accessed by any Thread/Stack.</li>
                    <li><strong>Stack area</strong> stores method specific values that are short-lived and are referenced to other objects in the heap.</li>
                    <li><strong>Stack frame</strong> Every frame  consist of own Local Variable Array (LVA), Frame Data (FD) and Operand Stack (OS). Only one frame is active in a Heap - current frame.</li>
                </ul>
                <h3>Garbage Collector</h3>
                    <p>Any object that is not accessible to any thread is considered dereferenced and becomes available for GC.</p>
                    <div class="container_grid_common container_GC">
                        <div style="background-color: inherit; grid-area: con-1;"></div>
                        <div style="font-style: italic; background-color: inherit; padding: 0; border-bottom: solid 1px rgb(51, 51, 51); grid-area: con-2;">Survivor Space</div>
                        <div style="background-color: inherit;  grid-area: con-3;"></div>
                        <div style="background-color: rgb(127, 150, 190); grid-area: con-4;">eden</div>
                        <div style="background-color: rgb(163, 217, 230); grid-area: con-5;">S0</div>
                        <div style="background-color: rgb(198, 183, 158); grid-area: con-6;">S1</div>
                        <div style="background-color: rgb(170, 230, 189); grid-area: con-7;">Tenured</div>
                        <div style="background-color: rgb(157, 193, 254); grid-area: con-8;">Permanent</div>
                        <div style="font-style: italic; background-color: inherit; border-top: solid 1px rgb(51, 51, 51); grid-area: con-9;">Young Generation</div>
                        <div style="font-style: italic; background-color: inherit; border-top: solid 1px rgb(51, 51, 51); grid-area: con-10;">Old Generation</div>
                        <div style="font-style: italic; background-color: inherit; border-top: solid 1px rgb(51, 51, 51); grid-area: con-11;">Metaspace</div>
                    </div>
                    <ol>
                        <li><strong>Young Generation</strong> - all new objects. A minor GC occurs here.</li>
                        <li><strong>Tenured Generation</strong> - long surviving objects.</li>
                        <li><strong>Metaspace</strong> Stores static data, which is accessible anytime.</li>
                    </ol>
                <h3>Java Volatile Keyword</h3>
                <p>The Java volatile keyword is used to mark a Java variable as "being stored in main memory" (RAM). Every write to a volatile variable will be written to main memory, and not just to the CPU registers. E.g.:</p>
<pre><code>public <strong>volatile</strong> int counter = 0;</code></pre>
                <p>Declaring a variable volatile thus guarantees the visibility for other threads of writes to that variable.</p>
                <p><em>if two threads are both reading and writing to a shared variable, then using the volatile keyword for that is not enough.</em> You need to use a synchronized in that case to guarantee that the reading and writing of the variable is atomic. Reading or writing a volatile variable does not block threads reading or writing. For this to happen you must use the synchronized keyword around critical sections.</p>
                <p>As an alternative to a synchronized block you could also use one of the many atomic data types found in the java.util.concurrent package. For instance, the AtomicLong or AtomicReference or one of the others.</p>
                <p>In case only one thread reads and writes the value of a volatile variable and other threads only read the variable, then the reading threads are guaranteed to see the latest value written to the volatile variable. Without making the variable volatile, this would not be guaranteed.</p>
                <h3>Java Synchronized Blocks</h3>
                    <p>A Java synchronized block marks a method or a block of code as synchronized. A synchronized block in Java can only be executed a single thread at a time (depending on how you use it). Java synchronized blocks can thus be used to avoid <strong>race condition</strong>.</p>
                    <p>If two or more threads share an object, and more than one thread updates variables in that shared object, <strong>race conditions</strong> may occur.</p>
                    <p>One Thread can block section only once, and any other Thread which awaits to access a block can block a block.</p>
<pre><code>// Synchronized method
public <strong>synchronized</strong> void add(int value){ ... }
// Synchronized block
public void add(int value) { <strong>synchronized(this)</strong> { ... } }</code></pre>
                    <p>Synchronization should be used carefully as it may block other Threads forever and make progress stop due to wait time.</p>
                <h2>Initializing Object Using the Constructor Method</h2>
                <pre><code>public class Clothing {
    private String description;
    public double price;
    public Clothing () {
    } // "no-argument do-nothing Constructor" needed to be added as soon as parameterized constructor is added.

    public Clothing (String description, double price) {
        this.description = description;
        this.price = price;
    } // Another Constructor
    /* remaining methods */
}</code></pre>
                <p>Initialize an object</p>
                <pre><code>public static void main (String[] args) {
    Clothing item = <strong>new Clothing ();</strong>
    // invoke set methods for item1 to initialize data
    Clothing item = <strong>new Clothing ("Jacket", 20.99, "M");</strong>
    // item2 is already initialized
}</code></pre>
                <h2>Static Methods</h2>
                <p>It is a e.g. a <strong>static variable value</strong> that is shared by all objects of a class. Or it can be a <code>public static void filter(Database data){...}</code> method of a class, which you want to execute some process to perform an action.</p>
                <ul>
                    <li>Is <i>not specific</i> to any object instance</li>
                    <li>Can be accessed without instantiating the class (<code>new</code>), e.g. <code>Math.random()</code>.</li>
                    <li>Static variables sees only other static variables, therefor can not access instance (internal) variables.</li>
                    <li>Can not be overridden by other classes.</li>
                </ul>
                <h2>Handling Exceptions - the <code>try/catch</code> Block</h2>
                <pre><code><strong>try {</strong>
    Clothing[] items = new Clothing[10];
    items[0].description = "Pink Boiler Suit";
<strong>}   catch (NullPointerException e) { // Name of the exception</strong>
    String errMsg = e.getMessage();
    e.printStackTrace();
<strong>}   catch (Expectation e) {
    ...
}</strong><strong>   finally { ... }</strong> // May be used. Runs always, independently from catching an exception. May have a resource leak. Use try with resources instead.</code></pre>
                <ul>
                    <li><code>try</code> block contains logic that can potentially result in expectations.</li>
                    <li><code>catch</code> block contain logic that handles expectations.</li>
                </ul>
                <p>Nested try blocks can be used when some specific section an a big code can cause a specific exception.</p>
                <h3>Exception classes</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Class</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>RuntimeException</td>
                            <td>Exceptions that can occur during normal operation of the Java virtual machine.</td>
                        </tr>
                        <tr>
                            <td>NullPointerException</td>
                            <td>Occurs when a method attempts to access an object member through a null reference.</td>
                        </tr>
                        <tr>
                            <td>IOException e</td>
                            <td>Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.</td>
                        </tr>
                    </tbody>
                </table>
                <h3>Exception invokers</h3>
                <p>The <code>throw</code> keyword is used to create an exception. We specify the exception object that should be thrown. The exception contains a message describing the error. These exceptions can be related, for example, to validating input data for correctness, compliance with a certain criterion, etc.</p>
<pre><code>throw new ArithmeticException("The age is not right!"); // The string becomes a e.getMessage() value</code></pre>
                <p>The <code>throws</code> keyword is used to declare exceptions; indicates that an exception may occur in a method; does not throw an exception; always used with a method signature. The method must provide a throws clause that lists the exceptions.</p>
<pre><code>public void myMethod() throws SpaceInvadersException
{
    /* Code that might throw an exception */
}

public void callingMethod()
{
    try {
    myMethod();
    }
    catch (SpaceInvadersException exception) {
    /* Complicated error handling code */
    }
}</code></pre>
                <h3>Custom Exceptions</h3>
                <p>When we implement a custom exception, the <code>RuntimeException</code> - for not checked or <code>Exception</code> - for checked Class need to be extended:</p>
<pre><code>public class myException extends RuntimeException {
    public myException(String msg, Throwable cause) {
        super(msg, cause);
    }
}
...
return new myException("An exception: ", e).getMessage();</code></pre>
                <h3 id="try-with-resources">Try with resources</h3>
                <p>When we place references that are AutoClosable in the try declaration, then we don’t need to close the resource ourselves. The <code>try-with-resources</code> statement ensures that each resource is closed at the end of the statement. Any object that implements the <code>AutoCloseable</code> interface can be used as a resource.</p>
<pre><code>try (FileOutputStream fos = new FileOutputStream(Constants.BASE_PATH + "myfile2.txt");
BufferedReader br = new BufferedReader(new FileReader(Constants.BASE_PATH + "myfile.txt"))) {
    ...
} catch {...}</code></pre>
                <p>The <code>FileOutputStream</code> implements a AutoCloseable, hence the file will be automatically closed after the process is done.</p>
                <h2>Object-Oriented Approach to Code Reuse</h2>
                <h2>Inheritance</h2>
                <p>We create a Class "Gadget" for Subclasses "Camera()" and "TV()", which is called a Superclass.</p>
                <p>Super class stores common attributes and behavers, subclasses however may overwrite them and have more specific execution.</p>
                <p>Hoverer, "Gadget" Superclass can not have is record a video method and change a chanel, because it will be not common for all Gadgets.</p>
                <p>There could be any number of levels in the hierarchy, from very general to very specific child types.</p>
                <p>Sometimes, inheritance is unwelcome. Therefore, classes which must not be extended are marked with a <code>final</code> access modifier. E.g. <code>public final class Animal {...}</code></p>
                <p>Object is the top-level class in a Java class hierarchy.</p>
                <div>                    
<pre><code>public static void main(String[] args) {
    Clothing[] items = new Clothing[2];
    items[0] = new Tailored();
    items[1] = new Standard();
    for (Clothing item: items) {
        item.getPrice();
    }
}</code></pre>
<pre><code>public class Clothing extends Object { // No need to specify extend Object words here for the SuperClass
    private double price;
    public double getPrice() {
        return price;
    }
}</code></pre>
                    <p>The code below override common behaver.</p>
<pre><code>public class Tailored <strong>extends</strong> Clothing { // The extend word here is mandatory
    private double fee;
    @Override
    public double getPrice() {
        return super.getPrice() + fee;
    }
}</code></pre>
                </div>
                <p>A method in a subclass must have exactly the same name, return type, and parameters as the method in the parent class, that is, the method signature. If they do not match, the method will not be overridden.</p>
                <p>The access level cannot be more restrictive in the subclass. For example, if a method in the parent class is public, the overridden method in the subclass cannot be private or protected.</p>
                    <h3>Inheritance level</h3>
                        <ul>
                            <li>Single</li>
                            <li>Multi</li>
                            <li>Hierarchical</li>
                            <li>Multiple/Hybrid/Diamond - is not allowed in Java, but can be achieved by Interfaces</li>
                        </ul>
                <h2>Abstract and Interface classes - common behaver</h2>
                    <p>There are several common principles between abstract and</p>
                    <ul>
                        <li>Both classes cannot be directly instantiated (creating new instances of objects to be used in a program), if it is marked with the Abstract/Interface keyword.</li>
                        <li>The Abstract/Interface classes` purpose is to be extended by one or more concrete subclasses.</li>
                        <li>A subclass derived from an Abstract/Interface class must either implement all the base class’s abstract methods or be abstract itself.</li>
                    </ul>
                <h2>Define Abstract Classes & Methods</h2>
                <p>The Abstract keyword can be used to encourage class extensibility. It is vise versa to Inheritance method. Is used when there is no shared pice of code whatsoever and all subclasses uses their uniq execution. So that is to provide a design and polymorphism.</p>
                <ul>
                    <li>Class cannot be directly instantiated (creating new instances of objects to be used in a program), if it is marked with the abstract keyword.</li>
                    <li>The abstract class purpose is to be extended by one or more concrete subclasses.</li>
                    <li>The abstract methods describe method signatures without a method body.</li>
                    <li>An abstract class can declare both abstract and concrete methods.</li>
                    <li>If a class defines one or more abstract methods, then the class itself must be declared abstract.</li>
                    <li>A subclass derived from an abstract class must either implement all the base class’s abstract methods or be abstract itself.</li>
                    <li>A sub-class can inherit only one abstract class.</li>
                </ul>
<pre><code>public <strong>abstract</strong> class Clothing {
    public <strong>abstract</strong> double refund();
    void changeColor() {
        System.out.println("Color is green");
    }
}
// A sub-class MUST override all abstract methods
// of the abstract class;
// A sub-class MAY override all non-abstract methods
// of an abstract class.</code></pre>
<pre><code>public class <strong>Tailored</strong> extends Closing {
    // MUST be overridden
    public double refound() {
        <strong>Return 0;</strong>
    }
    // MAY be overridden
    @Override
    void changeColor() {
        System.out.println("Color is red");
    }
}</code></pre>
<pre><code>public class <strong>Standard</strong> extends Clothing {
    public double refund() {
        // MUST be overridden
        <strong>return getPrice();</strong>

        // Private method of this class that is NOT overridden
        void addPrice() {
            System.out.println("Price is 30 $");
        }
    }
}</code></pre>
                
                <pre style="color: rgb(246, 69, 69);"><code><strong>Clothing</strong> jacket1 = new <strong>Clothing</strong>();</code></pre>
                <p>Abstract classes can be used to create references to objects.</p>
                <pre style="color: green;"><code><strong>Clothing[]</strong> items = new <strong>Clothing</strong>[3];</code></pre>
                <pre><code><strong>Clothing</strong> jacket2 = new <strong>Tailored</strong>();
jacket2.refund();
jacket2.changeColor(); // "Color is red"</code></pre>
                <pre><code><strong>Clothing</strong> jacket3 = new <strong>Standard</strong>();
jacket3.refund();
jacket3.changeColor(); // "Color is green."
// ERROR
// addPrice() method does not exist in Clothing.
// jacket3.addPrice();
// Then we need to:</code></pre>
                <pre><code><strong>Standard</strong> jacket4 = new <strong>Standard</strong>();
jacket4.refund();
jacket4.addPrice();</code></pre>
                <h2>Java Interfaces</h2>
                <p>An interface defines a set of features that can be applied to various other classes.</p>
                <ul>
                    <li>Instance methods are by default public, static and abstract.</li>
                    <li>Class cannot be directly instantiated, if it is marked with the Interface keyword.</li>
                    <li>They can contain concrete methods, but only if the methods are either <code>default</code>, <code>private</code>, or <code>static</code>. In case of <code>default</code> this means that, the classes which implements this interface can not inherit its methods. You can access Interface methods by calling them directly.</li>
                    <li>They can contain constants but not variables.</li>
                    <li>
                        By default, constants are MARKED AS <code>public static final</code> and constants can be used in an implementation class WITHOUT an interface name prefix.
                        <em>Note that, IF by coincidence the name of a class variable/constant matches a constant defined in an implemented interface, the local class variable/constant overrides the interface constant. The constant is converted to a variable and can be changed as many times as desired.</em>
                    </li>
                </ul>
                <pre><code>public <strong>interface</strong> Recyclable {
    // A Constant in the Interface
    String MEASURE = "meter";            
    <strong>void recycle();</strong>
}</code></pre>
                <pre><code>public class Clothing <strong>implements</strong> Recyclable {
    // Use of the constant
    // without an interact prefix "Recyclable."
    String measure = MEASURE;

    // The compiler will now require that method recycle
    // be implemented. Compilation will fail if this
    // method is missing from this class.
    <strong>public void recycle() {
        /* clothing specific implementation */
    }</strong>
}</code></pre>
                <pre><code>public class Bottle <strong>implements</strong> Recyclable {
    <strong>public void recycle() {
        /* bottle specific implementation */
    }</strong>
}</code></pre>
                <p><strong>Notes</strong>: Interface resembles an abstract class, except no variables or regular concrete methods are allowed.</p>
                <h3>Implement Interfaces</h3>
                <ul>
                    <li>Object-oriented inheritance is not flexible.</li>
                    <li>
                        Depending on the point of view, a given class may require different parents (to be of more than one type.)
                        <pre><code>public class ColorCircle extends Circle implements Shape {
    ...
}</code></pre>
                    </li>
                    <li>Different features can be defined by different interfaces.</li>
                    <li>
                        A class can implement as many interfaces as required.
                        <pre><code>public class Clothing <strong>implements</strong> Recyclable, Comparable {
    <strong>public void recycle() { ... }
    public int void compareTo(Object other) { ... }</strong>
}</code></pre>
                    </li>
                    <li>
                        It is also possible for an interface(s) to inherit (extend) from an interface. And then even another class can implement the extended interface.
                        <pre><code>public interface ProductC extends ProductA, ProductB {
    void getProductCInfo();
}</code></pre>
                    </li>
                </ul>
                <h2>Enums</h2>
                <p><code></code></p>
                <h2>Java Classes</h2>
                <h3>Classes-Wrappers</h3>
                <p>Classes-Wrappers are used to transform primitive data into an Object.</p>
<pre><code>int num = 55;
String strByte = "25"

// Convert a primitive or a String into an Object
Integer obj = Integer.valueOf(num); 
Integer obj1 = Integer.valueOf(strByte); 

// Convert an Object or a String to primitive
int var01 = obj.intValue();
int var02 = Integer.parseInt(strByte);</code></pre>
                <h3>Scanner</h3>
                <p><code>Scanner implements Iterator&lt;String&gt;, Closeable</code></p>
                <h4>Constructors</h4>
<pre><code>// Params: source - An input stream to be scanned
Scanner(InputStream source)
// Params: source - A file to be scanned
Scanner(File source)</code></pre>
                <h4>Methods</h4>
<pre><code>// Returns: the line that was skipped
String nextLine();
// Params: pattern - A string specifying a delimiting pattern
Scanner useDelimiter(String pattern)
// Returns true if this scanner has another token in its input.
boolean hasNext()
// Finds and returns the next complete token from this scanner.
String next()</code></pre>
                <h3>ArrayList</h3>
                <p>The <code>ArrayList</code> class is a resizable array. Elements in an ArrayList are actually objects. To use other types, such as int, you must specify an equivalent wrapper class, e.g.: <code>Integer</code>.</p>
                <p>The difference between a built-in array and an <code>ArrayList</code> in Java, is that the size of an array cannot be modified (if you want to add or remove elements to/from an array, you have to create a new one). While elements can be added and removed from an <code>ArrayList</code> whenever you want.</p>
<pre><code>Character a = 'a';
ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();
list.add(a);
// Access an item by the collection index
list.get(0);
// Change an item
list.set(0, "b");
// Remove an item or all the elements
list.remove(0);
list.clear();

list.size();

String s = (String) list.get(0); // Hard type cast. Changing a list data type to a string
</code></pre>
                <h3>Collections</h3>
                <p>The <code>Collections</code> class has a useful <code>sort()</code> method</p>
<pre><code>Collections.sort(list);</code></pre>
                <h3>Regular Expressions, Regex</h3>
                <p>Regular expressions are patterns used to match character combinations in strings. Regular expressions are also objects.</p>
                <h3>Regex specific</h3>
                <ul>
                    <li><strong>Coupling</strong> <code>ab</code> - forms an expression, i.e. AND</li>
                    <li><strong>Alternation</strong> <code>a|b</code> - OR</li>
                    <li><strong>Clothing</strong> <code>a*</code> - all variating: a, aa, aaa</li>
                </ul>
                <h3>Regex classes</h3>
                <ul>
                    <li>
                        <code>Class Pattern</code>
                        <p>A compiled representation of a regular expression.</p>
                        <p>A regular expression, specified as a string, must first be compiled into an instance of this class. The resulting pattern can then be used to create a Matcher object that can match arbitrary character sequences against the regular expression. All of the state involved in performing a match resides in the matcher, so many matchers can share the same pattern.</p>
<pre><code>Pattern p = Pattern.compile("a*b");
Matcher m = p.matcher("aaaaab");
boolean b = m.matches();</code></pre>
<pre><code>boolean b = Pattern.matches("a*b", "aaaaab");</code></pre>
                        <p>The statement above is equivalent to the three first above, though for repeated matches it is less efficient since it does not allow the compiled pattern to be reused.</p>
                    </li>
                    <li>
                        <code>Class Matcher</code> An engine that performs match operations on a character sequence by interpreting a Pattern.
                        <p>A matcher is created from a pattern by invoking the pattern's matcher method. Once created, a matcher can be used to perform three different kinds of match operations:</p>
                        <ul>
                            <li>The <code>matches</code> method attempts to match the entire input sequence against the pattern.</li>
                            <li>The <code>lookingAt</code> method attempts to match the input sequence, starting at the beginning, against the pattern.</li>
                            <li>The <code>find</code> method scans the input sequence looking for the next subsequence that matches the pattern. If multiple occurrences are found in the string, then the first call to find() will jump to the first occurrence. Thereafter, each subsequent call to the find() method will go to the next matching occurrence, one by one.</li>
                        </ul>
                        <p>Each of these methods returns a boolean indicating success or failure.</p>
<pre><code>Pattern pattern = Pattern.compile("sho*", Pattern.CASE_INSENSITIVE);
Matcher mtch = pattern.matcher("Sunny shop is a good shop");
    
while (mtch.find()) {
    System.out.println("Pattern found from " + mtch.start() + " to " + (mtch.end() - 1));
}</code></pre>
                    </li>
                    <li><code>Class PatternSyntaxException</code> Unchecked exception thrown to indicate a syntax error in a regular-expression pattern.</li>
                    <li>
                        <code>Interface MatchResult</code> The result of a match operation.
                        <p>This interface contains query methods used to determine the results of a match against a regular expression. The match boundaries, groups and group boundaries can be seen but not modified through a MatchResult.</p>
                    </li>
                </ul>
                <h3>Creating a regular expression</h3>
                <p>You construct a regular expression in one of two ways:</p>
                <ul>
                    <li>
                        <p><strong>String Literals</strong> - exact match.</p>
<pre><code>Pattern.matches("abc", "abc") // Returns true</code></pre>
                    </li>
                    <li>
                        <p><strong>Character Classes</strong> - either.</p>
<pre><code>Pattern.matches("[pqr]", "r"); // Returns true</code></pre>
                        <p>Example: <code>[Cc]ompany</code> will match all occurrences of the string "company" with the letter C in either lowercase or uppercase.</p>
                    </li>
                </ul>
                <h3>Regex methods</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Method</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>matcher.group();</td>
                            <td>Returns the input subsequence matched by the previous match. I.e. returns matched result</td>
                        </tr>
                        <tr>
                            <td>matcher.start();</td>
                            <td>Returns the start index of the previous match</td>
                        </tr>
                        <tr>
                            <td>matcher.end();</td>
                            <td>Returns the end index of the previous match</td>
                        </tr>
                        <tr>
                            <td>matcher.replaceFirst(String replacement);</td>
                            <td>Replaces the first subsequence of the input sequence that matches the pattern with the given replacement string</td>
                        </tr>
                        <tr>
                            <td>matcher.replaceAll(String replacement);</td>
                            <td>Replaces every subsequence of the input sequence that matches the pattern with the given replacement string</td>
                        </tr>
                    </tbody>
                </table>
                <h4>Regex Character classes</h4>
                <table>
                    <thead>
                        <tr>
                            <th>Character Class</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>[xyz]</td>
                            <td>x,y or z</td>
                        </tr>
                        <tr>
                            <td>[^xyz]</td>
                            <td>Any single character other than x,y or z</td>
                        </tr>
                        <tr>
                            <td>[a-zA-Z]</td>
                            <td>Characters from range a to z or A to Z.</td>
                        </tr>
                        <tr>
                            <td>[a-f[m-t]]</td>
                            <td>Union of a to f and m to t.</td>
                        </tr>
                        <tr>
                            <td>[a-z && p-y]</td>
                            <td>All the range of elements intersection between two ranges</td>
                        </tr>
                        <tr>
                            <td>[a-z && [^bc]]</td>
                            <td>a to z union with except b and c</td>
                        </tr>
                        <tr>
                            <td>[a-z && [^m-p]]</td>
                            <td>a to z union with except range m to p</td>
                        </tr>
                    </tbody>
                </table>
<pre><code>// Returns True
Pattern.matches("[tT]im|[jJ]in", "Tim");
Pattern.matches(".*abc.*", "deabcpq");
Pattern.matches("[a-zA-Z][a-zA-Z][a-zA-Z]", "aPz");
Pattern.matches("\\D*", "abcde");</code></pre>
                <h4>Predefined character classes</h4>
                <table>
                    <thead>
                        <tr>
                            <th>Regex</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>.</td>
                            <td>Any character</td>
                        </tr>
                        <tr>
                            <td>\d</td>
                            <td>Any digits, [0-9]</td>
                        </tr>
                        <tr>
                            <td>\D</td>
                            <td>Any non-digit, [^0-9]</td>
                        </tr>
                        <tr>
                            <td>\s</td>
                            <td>Whitespace character, [\t\n\x0B\f\r]</td>
                        </tr>
                        <tr>
                            <td>\S</td>
                            <td>ANon-whitespace character, [^\s]</td>
                        </tr>
                        <tr>
                            <td>\w</td>
                            <td>Word character, [a-zA-Z_0-9]</td>
                        </tr>
                        <tr>
                            <td>\W</td>
                            <td>Non-word character, [^\w]</td>
                        </tr>
                        <tr>
                            <td>\b</td>
                            <td>Word boundary</td>
                        </tr>
                        <tr>
                            <td>\B</td>
                            <td>Non -Word boundary</td>
                        </tr>
                    </tbody>
                </table>
<pre><code>Pattern.matches("...p", "qdqp") // Returns True</code></pre>
                <h4>Boundary Matchers</h4>
                <table>
                    <thead>
                        <tr>
                            <th>Regex</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>^</td>
                            <td>The beginning of a line</td>
                        </tr>
                        <tr>
                            <td>$</td>
                            <td>The end of a line</td>
                        </tr>
                        <tr>
                            <td>\b</td>
                            <td>A word boundary</td>
                        </tr>
                        <tr>
                            <td>\B</td>
                            <td>A non-word boundary</td>
                        </tr>
                        <tr>
                            <td>\A</td>
                            <td>The beginning of the input</td>
                        </tr>
                        <tr>
                            <td>\G</td>
                            <td>The end of the previous match</td>
                        </tr>
                        <tr>
                            <td>\Z</td>
                            <td>The end of the input but for the final terminator, if any</td>
                        </tr>
                        <tr>
                            <td>\z</td>
                            <td>The end of the input</td>
                        </tr>
                    </tbody>
                </table>
<pre><code>Pattern.matches("^Hello$", "Greetings! Hello"); // Returns False</code></pre>
                <p>Quantifiers. Quantification - searching for sequences</p>
                <h4>Greedy quantifiers</h4>
                <p>Greedy quantifiers try to cover everything they can — to the end of the line</p>
                <table>
                    <thead>
                        <tr>
                            <th>Regex</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>X?</td>
                            <td>X appears once or not</td>
                        </tr>
                        <tr>
                            <td>X+</td>
                            <td>X appears once or more than once</td>
                        </tr>
                        <tr>
                            <td>X*</td>
                            <td>X appears zero or not once</td>
                        </tr>
                        <tr>
                            <td>X{n}</td>
                            <td>X appears n times</td>
                        </tr>
                        <tr>
                            <td>X{n,}</td>
                            <td>X appears n times or more than n</td>
                        </tr>
                        <tr>
                            <td>X{n,m}</td>
                            <td>X appears greater than equal to n times and less than m times.</td>
                        </tr>
                    </tbody>
                </table>
                <h4>Reluctant quantifiers</h4>
                <p>Reluctant quantifiers cover a minimum set of characters and expand it if subsequent concatenated expressions fail.</p>
                <p>Adds <code>?</code> to a Greedy quantifiers</p>        
                <h4>Possessive quantifiers</h4>
                <p>Possessive quantifiers unlike regular (greedy) quantification, possessive quantification not only tries to find the longest possible variant, but also does not allow the algorithm to go back to previous search steps in order to find possible matches for the remaining part of the regular expression.</p>
                <p>Adds <code>+</code> to a Greedy quantifiers</p>
                <h3>Performance measure</h3>
                <ul>
                    <li><code>long start = System.currentTimeMillis(); System.out.println((System.currentTimeMillis() - start));</code></li>
                </ul>
                <h2>FileOutputStream</h2>
                <p>A file output stream is an output stream for writing data to a File or to a FileDescriptor.</p>
                <h2>Work with Files and Folders - java.io</h2>
                <p>When working with files, try-catch block needs to wrap code which works with file up. Check if the file is not null in finally block and use <code>close()</code> method to close it if not true. But it is a good practice to use <a href="#try-with-resources">try-with-resources</a> block to work with all mentioned classes in this section.</p>
                <h3>Supper Classes</h3>
                <ul>
                    <li>
                        <span><code>File</code></span>
<pre><code>boolean mkdir()
boolean createNewFile()
// dest - The new abstract pathname for the named file.
boolean renameTo(File dest)
boolean delete()
boolean exists()
// Returns: The name of the file or directory denoted by this abstract pathname, or the empty string if this pathname's name sequence is empty
String getName()
// Returns: A long value representing the time the file was last modified, measured in milliseconds since the epoch (00:00:00 GMT, January 1, 1970), or 0L if the file does not exist or if an I/O error occurs. The value may be negative indicating the number of milliseconds before the epoch
long lastModified()</code></pre>
                    <li>
                        <p><code>Writer</code> implements Appendable, Closeable, Flushable</p>
<pre><code>// str - String to be written.
void write(String str)
// Appends the specified character to this writer.
// Params: c - The 16-bit character to append
Writer append(char c)</code></pre>
                    </li>
                    <li><code>Reader</code> implements Readable, Closeable
<pre><code>// Returns: the character read, or -1 if the end of the stream has been reached
int read()</code></pre>
                    </li>
                    <li><code>OutputStream</code> implements Closeable, Flushable
<pre><code>// b - the data.
// off - the start offset in the data.
// len - the number of bytes to write.
void write(byte[] b, int off, int len)</code></pre>
                    </li>
                    <li><code>InputStream</code> implements Closeable
<pre><code>// Returns: the next byte of data, or -1 if the end of the file is reached.
int read()
// b - the buffer into which the data is read.
// Returns: the total number of bytes read into the buffer, or -1 if there is no more data
read(byte[] b, int off, int len)
// Returns: an estimate of the number of remaining bytes that can be read (or skipped over), or 0 when the file position is beyond EOF.
int available()</code></pre>
                    </li>
                </ul>
                <h3>Classes</h3>
                <ul>
                    <li><code>File(String pathname)</code> implements Serializable, Comparable&lt;File&gt;</li>
                    <li><code>FileWriter(String fileName, boolean append)</code> extends OutputStreamWriter, which extends Writer
                        <ul>
                            <li><code>append</code> - boolean if true, then data will be written to the end of the file rather than the beginning.</li>
                        </ul>
                    </li>
                    <li><code>FileReader(String fileName)</code> extends InputStreamReader, which extends Reader</li>
                    <li><code>FileOutputStream(String fileName)</code> extends OutputStream
<pre><code> // Is used in nio process
FileChannel getChannel()</code></pre>
                    </li>
                    <li><code>FileInputStream(String fileName)</code> extends InputStream
<pre><code>FileChannel getChannel()</code></pre>
                    </li>
                    <li>
                        <span><code>InputStreamReader(InputStream in, Charset cs)</code> extends Reader</span>
                        <ul>
                            <li><code>InputStream in</code> - e.g. <code>FileInputStream(path)</code></li>
                            <li><code>Charset cs</code> - e.g. <code>StandardCharsets.UTF_8</code></li>
                        </ul>
                    </li>
                    <li><code>BufferedWriter(Writer out)</code> extends Writer</li>
                    <li><code>BufferedReader(Reader in)</code> extends Reader
<pre><code>// Reads a line of text. A line is considered to be terminated by any one of a line feed ('\n'), a carriage return ('\r'), a carriage return followed immediately by a line feed, or by reaching the end-of-file (EOF).
// Returns: A String containing the contents of the line, not including any line-termination characters, or null if the end of the stream has been reached without reading any characters
String readLine()
// .collect(Collectors.joining(System.lineSeparator())); - read more in future
Stream&lt;String&gt; lines()</code></pre>
                    </li>
                </ul>
                <p>Without buffering, each invocation of <code>read()</code> or others could cause bytes to be read from the file, converted into characters, and then returned, which can be very inefficient.
                    Programs that use <code>DataInputStreams</code> or others for textual input can be localized by replacing each <code>DataInputStream</code> with an appropriate <code>BufferedReader</code> or <code>BufferWriter</code>.
                    Therefore, Writer or Reader Classes should be passed to a relevant Buffered Class.</p>
                <p><code>close()</code> method exists in any mentioned Classes in this section. May be used in <code>finally</code> block.</p>
                <h2>Java NIO (New Input/Output) API</h2>
                <ul>
                    <li>Non-blocking IO. While the channel reads data into the buffer, the thread can do something else. The same is true for writing data to channels.</li>
                    <li>Channels and Buffers. In the standard IO API you work with byte streams and character streams. In NIO you work with channels and buffers.</li>
                    <li><code>java.nio</code> and <code>java.nio.file</code> packages</li>
                </ul>
                <div class="container_grid_common container_jnio">
                    <div style="grid-area: con-1;">Data receiver</div>
                    <div style="grid-area: con-2;">Data source</div>
                    <div style="grid-area: con-3;">Channel</div>
                    <div style="grid-area: con-4;">Buffer</div>
                    <div style="grid-area: con-5;">Buffer</div>
                    <div style="grid-area: con-6;">Java program</div>
                    <i style="grid-area: con-7;"  class="line-horizontal arrow-line-right"></i>
                    <i style="grid-area: con-8;"  class="line-horizontal arrow-line-right"></i>
                    <i style="grid-area: con-9;"  class="line-horizontal arrow-line-right"></i>
                    <i style="grid-area: con-10;" class="line-horizontal arrow-line-left"></i>
                    <i style="grid-area: con-11;" class="line-horizontal arrow-line-left"></i>
                    <i style="grid-area: con-12;" class="line-horizontal arrow-line-left"></i>
                </div>
                <h3>Supper Classes</h3>
                <ul>
                    <li><code>Buffer</code>
<pre><code>// This value is set when the buffer is created. Once the buffer is full, it must be cleared before writing to it.
int capacity()
// It represents the number of active elements in the buffer.
int limit()
// Specifies the index of the next element to read or write.
int position()
// Sets this buffer's mark at its position.
// The position that is remembered. When we create a new ByteBuffer instance, the flag is undefined, the position is 0, and the limit is equal to the capacity.
Buffer mark()
// Flips this buffer. The limit is set to the current position and then the position is set to zero. I used to write bytes from the position 0 till limit into a file e.g.
Buffer flip()
// Prepares for reading. The position is set to zero, the limit is set to the capacity, and the mark is discarded.
Buffer clear()</code></pre>
                    <div class="container_grid_common container_buffer">
                        <i style="grid-area: con-1;">0</i>
                        <i style="grid-area: con-2;">1</i>
                        <i style="grid-area: con-3;">2</i>
                        <i style="grid-area: con-4;">3</i>
                        <i style="grid-area: con-5;">4</i>
                        <i style="grid-area: con-6;">5</i>
                        <i style="grid-area: con-7;">6</i>
                        <i style="grid-area: con-8;">7</i>
                        <i style="grid-area: con-9;">8</i>
                        <i style="grid-area: con-10;">9</i>
                        <div style="grid-area: con-14;"></div>
                        <div style="grid-area: con-15;"></div>
                        <div style="grid-area: con-16;"></div>
                        <div style="grid-area: con-17;"></div>
                        <div style="grid-area: con-18;"></div>
                        <div style="grid-area: con-19;"></div>
                        <div style="grid-area: con-20;"></div>
                        <div style="grid-area: con-21;"></div>
                        <div style="grid-area: con-22;"></div>
                        <div style="grid-area: con-23;"></div>
                        <i style="grid-area: con-11;" class="line-vertical arrow-line-down"></i>
                        <i style="grid-area: con-12;"></i>
                        <i style="grid-area: con-13;" class="line-vertical arrow-line-down"></i>
                        <i style="grid-area: con-24;">position</i>
                        <i style="grid-area: con-25;"></i>
                        <i style="grid-area: con-26;">limit, capacity</i>
                    </div>
                    </li>
                    <li><code>AbstractInterruptibleChannel</code> implements Channel, InterruptibleChannel</li>
                    <li><code>Charset</code> implements Comparable&lt;Charset&gt;
<pre><code>// Returns the default charset - UTF-8.
Charset defaultCharset()
// Params: bb – The byte buffer to be decoded.
// Returns: A char buffer containing the decoded characters.
CharBuffer decode(ByteBuffer bb)</code></pre>
                    </li>
                    <li><code>public interface Path</code> extends Comparable&lt;Path&gt;, Iterable&lt;Path&gt;, Watchable
<pre><code>static Path of(String first, String ... more)</code></pre>
                    </li>
                    <li><code>public final class Paths</code>
<pre><code>// Converts a path String, or a sequence of strings to a Path.
// Params: first – the path string or initial part of the path string; more – additional strings to be joined to form the path string
static Path get(String first, String... more)</code></pre>
                    </li>
                    <li><code>public final class Files</code>
<pre><code>public static Path createDirectory(Path dir, FileAttribute&lt;?&gt;... attrs)
public static Path createFile(Path path, FileAttribute&lt;?&gt;... attrs)
public static Path writeString(Path path, CharSequence csq, OpenOption... options)
// The method ensures that the file is closed when all content have been read.
public static String readString(Path path) throws IOException
public static void delete(Path path) throws IOException</code></pre>
                    </li>
                </ul>
                <h3>Classes</h3>
                <ul>
                    <li><code>ByteBuffer</code>, <code>CharBuffer</code>, <code>DoubleBuffer</code>, <code>FloatBuffer</code>, <code>IntBuffer</code>, <code>LongBuffer</code>, <code>ShortBuffer</code> extends Buffer implements Comparable&lt;ByteBuffer&gt;
<pre><code>Get/put, compact; allocate, wrap</code></pre>
                    </li>
                    <li><code>FileChannel</code> extends AbstractInterruptibleChannel implements SeekableByteChannel, GatheringByteChannel, ScatteringByteChannel
<pre><code>// Writes a sequence of bytes to this channel from the given buffer.
int write(ByteBuffer src)
// Reads a sequence of bytes from this channel into the given buffer.
// Bytes are read starting at this channel's current file position, and then the file position is updated with the number of bytes actually read.
int read(ByteBuffer dst)</code></pre>
                    </li>
                    <li><code>CharsetDecoder</code> transform chars into bytes and vise versa.</li>
                    <li><code>SelectableChannel</code> for multiplication</li>
                </ul>
                <h2>Multithreading</h2>
                    <p>Thread is a unit in a Process. Each Process has at least one Thread which consumes some of the Processes recourses and common memory area.</p>
                    <p>A program can be divided on several Processes.</p>
                    <p>How to create Multithreading:</p>
                    <ul>
                        <li>By Implementing of <code>Interface Runnable</code></li>
                        <li>By Extending <code>Class Thread</code> extends Class Object implements Interface Runnable</li>
                    </ul>
                    <h3>Interface Runnable</h3>
                        <p>The interface has only one method:</p>
<pre><code>run()</code></pre>
                        <p>If a Class implements the <code>Interface Runnable</code> our Class will be able to extend other basic Classes.</p>
                        <p>If used, gives an Object, which can be utilized by several Threads. The <code>Thread</code> Class <strong>must</strong> be initialized by passing our custom Class in Thread constructor and using <code>start() method.</code></p>
                        <p>When a start method is called using the <code>start()</code> method, then a new separate thread is allocated to execute the start method, so if more than one thread calls the <code>start()</code> method, it means that their start method is executed by separate threads (these threads execute simultaneously).</p>
                    <h3>Class Thread</h3>
                        <p>The class provides with the constructors and methods for creation and execution of operations on a Thread.</p>
                        <p>If a Class extends <code>Class Thread</code>, our Class will not be able to extend other Classes because of multi Inheritance. But we can extend it to reach of basic functions of Multithreading, which are not available in <code>Interface Runnable.</code></p>
                        <h4>Class Thread Constructor</h3>
<pre><code>// Params: task – the object whose run method is invoked when this thread is started. 
    public Thread(Runnable task)</code></pre>
                        <h4>Class Thread Methods</h3>
<pre><code>// Schedules this thread to begin execution. The thread will execute independently of the current thread.
// A thread can be started at most once. In particular, a thread can not be restarted after it has terminated.
public void start()
// Causes the currently executing thread to sleep (temporarily cease execution) for the specified number of milliseconds.
public static void sleep(long millis)
currentThread().getName()
// Waits for this thread to terminate. And then proceed executing below code.
public final void join() throws InterruptedException
// Tests if this thread is alive. A thread is alive if it has been started and has not yet terminated.
public final boolean isAlive()
// A hint to the scheduler that the current thread is willing to yield its current use of a processor. The scheduler is free to ignore this hint.
public static void yield()
// The interrupt() method allows you to interrupt a sleeping or waiting thread. An interrupt is an instruction to a thread that it should stop what it is doing and do something else. If the target thread is not in a sleep or wait state, the interrupt call will wait until the target thread enters a sleep or wait state.
public void interrupt()
// Tests whether the current thread has been interrupted. If this method were to be called twice in succession, the second call would return false
public static boolean interrupted()
public final void setPriority(int newPriority)
// Returns the Thread object for the current thread. Used to perform final methods on.
public static native Thread currentThread();
public final boolean isDaemon()
public final void setDaemon(boolean on)

*** Virtual Threads

// Creates a virtual thread to execute a task. Returns: a new, and started, virtual thread. Both below are equivalents.
public static Builder.OfVirtual ofVirtual().start(Runnable task)
public static Thread startVirtualThread(Runnable task)
public final boolean isVirtual()</code></pre>
                            <p>Creation of a <strong>Thread</strong> is a heavy and expensive process, therefore use minimum of it.</p>
                            <p>While standard Thread relise on the OS executor and planner it can not handle many Threads as they require good amount of Stack memory. Therefore there is a Project LOOM, which implemented Virtual, more light weight Threads which are build and planned by the JVM, an <code>ofVirtual()</code> method to the <code>Thread</code> class.</p>
                    <h3>Thread priorities</h3>
                        <p>The priority of a Thread can be set up. They are represented by Integers from 1 to 10, where 1 is the lowest priority. The default priority is 5. The Threads inherit a priorities from the super Class. In Java the very first and Main Thread is the Main class.</p>
                        <p><code>Class Thread</code> defines Constants for several default priorities:</p>
                        <ul>
                            <li><code>MIN_PRIORITY</code> = 1</li>
                            <li><code>NORM_PRIORITY</code> = 5</li>
                            <li><code>MAX_PRIORITY</code> = 10</li>
                        </ul>
                        <p>If a Thread with the higher priority launches, it will supersede a Thread with lower priority. It is called <strong>Context Switching</strong></p>
                    <h3>Daemon Thread</h3>
                        <p>The Thread has low priority and works ob a background. The common example is the GC. If all others Threads has finished their work, this thread can not stop a program from being closed.</p>
                    <h3>Synchronizers</h3>
                        <p>Counter of Access... To be continued</p>
                    <h3>Atomic variables</h3>
                        <ul>
                            <li>In programming, an atomic action is one that effectively happens all at once. An atomic action cannot stop in the middle: it either happens completely, or it doesn't happen at all.</li>
                            <li>Atomic classes use Compare and Swap method which is faster then blocking algorisms.</li>
                        </ul>
                        <h4>Atomic Classes</h4>
                            <ul>
                                <li><code>AtomicInteger</code>, <code>AtomicBoolean</code>, <code>AtomicLong</code> and arrays of them. Bellow definitions are based on Integer, but they have same methods.
                                    <h5>Constructors</h5>
<pre><code>public AtomicInteger(int initialValue)</code></pre>
                                    <h5>Methods</h5>
<pre><code>public final boolean compareAndSet(int expectedValue, int newValue)
// Returns: the previous value.
public final int getAndSet(int newValue)
// Returns: the updated value.
public final int addAndGet(int delta)
// Returns: the updated value
public final int decrementAndGet()
public final int getAndIncrement()</code></pre>
                                </li>
                            </ul>
                    <h3>Inter-Thread communication</h4>
                    <p>Mechanism in which a thread is terminated in its critical section and another thread is allowed to enter (or block).</p>
                    <ul>
                        <li>The current thread must own the monitor of this object, which means that the object which has a synchronized block need to be manipulated by this thread, so it should only be called from a synchronized method, otherwise it will throw an exception.</li>
                        <li>Monitor Concept. A monitor can be thought of as a box that can only hold one thread. Once a thread enters the monitor, all other threads must wait until that thread exits the monitor.</li>
                    </ul>
                    <p><code>Class Object</code></p>
<pre><code>// Causes the current thread to wait until it is awakened, typically by being notified or interrupted or unless the specified time ends.
public final void wait()
public final void wait(long timeoutMillis)
// Wakes up a single thread that is waiting on this object's monitor. If any threads are waiting on this object, one of them is chosen to be awakened.
public final native void notify()
// Wakes up all threads that are waiting on this object's monitor.
public final native void notifyAll()</code></pre>
                    <h3>Advanced synchronization - Lock Objects</h3>
                    <p><strong>Synchronized</strong> key word has a limitation in providing methods for control of which next Thread will take a control next.</p>
                    <h4>Supper Classes</h4>
                    <ul>
                        <li><code>public interface Lock</code> It allows explicit locking and unlocking, supports various locking strategies.
<pre><code>// Acquires the lock.
void lock();
// Releases the lock.
void unlock()
// lock the lock only when it the current Thread not interrupted before. If it was interrupted, the InterruptedException is thrown.
void lockInterruptibly() throws InterruptedException
// tries to lock a Lock within a given time. If not locked, proceeds with no lock held. Use it with if, else statement.
boolean tryLock(long time, TimeUnit unit) throws InterruptedException;</code></pre>
                        </li>
                        <li><code>public interface ReadWriteLock</code> The ReadWriteLock interface provides a way to distinguish between read and write locks. This allows multiple threads to read a shared resource simultaneously, while providing exclusive write access.
<pre><code>// Returns the lock used for reading.
Lock readLock()
// Returns the lock used for writing.
Lock writeLock()</code></pre>
                        </li>
                        <li><code>public class Semaphore</code> implements Serializable
                            <p>It works in an order that the first Thread acquires one permit from the Semaphore. Unless the ammount of permits > 0, Threads will be able to work on an Object with run method symulteniuasly. Otherwise other Threads will be waiting for the Thread which auired a permit to release it.</p>
                            <h5>Constructor</h5>
<pre><code>// Creates a Semaphore with the given number of permits and nonfair fairness setting.
Semaphore(int permits)</code></pre>
                            <h5>Methods</h5>
<pre><code>// Acquires a permit from this semaphore, blocking until one is available, or the thread is interrupted.
void acquire()
// Releases a permit, returning it to the semaphore.
void release()</code></pre>
                        </li>
                        <li><code>Class CountDownLatch</code>
                            <p>The constructor needs to be initialized in the Thread which need to wait for other Threads by using a <code>await()</code> method. The <code>countDown()</code> method needs to be called in the each N Thread on the exact constructed CountDownLatch Object after the completion of the each Thread, which dicrease the count of N by 1 till 0. Then the "main" Thread will be able to preceed.</p>
                            <h5>Constructors</h5>
<pre><code>// Waits for the N number of Threads to 
CountDownLatch(int count)</code></pre>
                            <h5>Methods</h5>
<pre><code>// The process will stop until other N of threads finish their work.
await()
// Signalize to the counter to decrement itself.
countDown()</code></pre>
                        </li>
                        <li><code>Class CyclicBarrier</code>
                            <p>The object of the CyclicBarrier Class is constructed with the N number of Threads to wait. Threads call await() method of the Class. When the ammount of call reaches the N number then the main Thread proceeds.</p>
<pre><code>// Creates a new CyclicBarrier that will trip (work) when the given number of parties (threads) are waiting upon it, and which will execute the given barrier action (object passed into its constructor) when the barrier is tripped (reached N ammount of waits), performed by the last thread entering the barrier.
CyclicBarrier(int parties, Runnable barrierAction)

// Stops this Thread
await()</code></pre>
                        </li>
                        <li><code>public class Exchanger&lt;V&gt;</code> - Type Parameters: V - The type of objects that may be exchanged.
                            <p>Forms a point where Threads can exchange information. The Threads are blocked until they exchange the information.</p>
<pre><code>// Waits for another thread to arrive at this exchange point (call this method passing an exchange Object into it), and then transfers the given object to it, receiving its object in return.
// Returns: the object provided by the other thread nad points to the object`s address memory cell.
public V exchange(V x) throws InterruptedException</code></pre>
                        </li>
                        <li><code>public class Phaser</code>
                            <p>May consist of several phases. Each phase may consist of several parties, each have to <strong>arrive</strong> to a barrier to complete a phase.</p>
                            <ul>
                                <li>Registration of parties for the phaser happens through <code>register()</code> method.</li>
                                <li>To signal that a group arrived to the phase, use <code>arrive()</code> method</li>
                                <li>As soon as all Threads registered for the phase reach a barrier, this phase is considered to be ended and a new phase begins.</li>
                            </ul>
<pre><code>// Params: parties – the number of parties required to advance to the next phase
public Phaser(int parties)

***

// Params: parties – the number of additional parties required to advance to the next phase
// Returns: the arrival phase number to which this registration applied.
public int register()
public int bulkRegister(int parties)
// Arrives at this phaser and deregisters from it without waiting for others to arrive. Deregistration reduces the number of parties required to advance in future phases.
// Returns: the arrival phase number, or a negative value if terminated.
public int arriveAndDeregister()
// Arrives at this phaser and awaits others. 
// Returns: the arrival phase number
public int arriveAndAwaitAdvance()
// Returns the current phase number.
public final int getPhase()</code></pre>
                        </li>
                    <h4>Classes</h4>
                    <ul>
                        <li><code>public class ReentrantLock implements Lock, java.io.Serializable</code> has an advantage in being re-entrant, meaning can block a section more then once.
                            <p>Normally <code>Lock</code> Object is created with the <code>new ReentrantLock</code>, but it would then not have the <code>ReentrantLock</code> methods.</p>
<pre><code>// Params: fair – true locks favor granting access to the longest-waiting thread.
public ReentrantLock(boolean fair)

// Returns: the number of holds (locks called) on this lock by the current Thread
public int getHoldCount()
// Returns: the number of Threads waiting for the lock
public final int getQueueLength()
// Queries whether the given Thread is waiting to acquire this lock.
public final boolean hasQueuedThread(Thread thread)
// Queries whether any threads are waiting to acquire this lock
public final boolean hasQueuedThreads()
public boolean isLocked()
public boolean isHeldByCurrentThread()</code></pre>
                        </li>
                        <li><code>public class ReentrantReadWriteLock</code> implements ReadWriteLock, java.io.Serializable
                            <p>Consist of <code>writeLock()</code> and <code>readLock()</code> methods. In addition with <code>lock()</code> and <code>unlock()</code> blocks Threads. The <code>writeLock()</code> can be held only by one Thread while others waiting. The <code>readLock()</code> may be held simultaneously by multiple reader threads. Each of two Locks alone will not be acquired unless another is fully unlocked by queued Threads. Whichever lock is blocked by the most waited Thread, that lock is going to be preceded next. This lock is used for e.g. update of the database in writeLock and synchronize all the resources with the database in readLock.</p>
<pre><code>public ReentrantReadWriteLock.WriteLock writeLock()
public ReentrantReadWriteLock.ReadLock readLock()</code></pre>
                        </li>
                    </ul>
                    <hr>
                    <ol>
                        <li>Create ExecutorService object</li>
                        <li>Create Thread Pool from that Object</li>
                        <li>Execute on that Object with passed tasks. You can submit instead.</li>
                    </ol>

                    <h4>public interface Executor</h4>
                        <p>In large applications, it makes sense to separate thread management and creation from the rest of the program. The objects that encapsulate these functions are known as Executors.</p>
                        <p>The Executor Framework contains a set of components used for efficient thread management.</p>
                        <p>The Producer Threads delivers tasks and place them in order, which preceded further by the Consumer Threads.</p>
                        <aside>
                            <p>
                                Producer-Consumer - is a parallelism shablon, where Producer Thread creates an object and Consumer Thread consumes it.
                            </p>
                        </aside>
<pre><code>// Executes the given command at some time in the future. The command may execute in a new thread, in a pooled thread, or in the calling thread, at the discretion of the Executor implementation. Delivers a task sort to say.
// Params: command – the runnable task
void execute(Runnable command)</code></pre>

                    <h4>public interface ExecutorService extends Executor, AutoCloseable</h4>
                        <p>Adds more functionality to the <code>Executor</code> interface.</p>
                        <p>The Main Thread may <strong>execute</strong> (deliver) a task to the executorService (Thread Pool), and then other Threads can take them.</p>
<pre><code>// Instead of execute. Gives information (status) about the task.
Future&lt;?&gt; submit(Runnable task)
&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result)
&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)
// Calls whatever response first, terminates other calls just afte the first response. Used e.g. to call a server to speed up the execution.
&lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)
// Executes all items from the Collection. Returns a list of Futures
&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)
// Shots down the executorService when all the tasks are done.
void shutdown()
// shuts down all the pending tasks (which are waiting in que) and returns them. It returns the list immediately. The tasks which have been already running will continue to run.
List&lt;Runnable&gt; shutdownNow()
// shotdownNow method will not guarantee immediate shot down, as some tasks may already run. Hence you may use the following command to wait until the termination of the executor Service.
boolean awaitTermination(long timeout, TimeUnit unit)</code></pre>

                    <h4>public class ThreadPoolExecutor extends AbstractExecutorService</h4>
                    <p><strong>AbstractExecutorService</strong> class implements <strong>ExecutorService</strong>.</p>
                    <p>The <strong>ThreadPoolExecutor</strong> as it implements the ExecutorService, can be used to create an ExecutorService.</p>
<pre><code>// Params:
// corePoolSize – the number of starting threads to keep in the pool, even if they are idle, unless allowCoreThreadTimeOut is set
// maximumPoolSize – the maximum number of threads to allow in the pool. Can be useful when a longer task comes up where you do not want other Threads to queue.
// keepAliveTime – when the number of threads is greater than the core (starting number of threads), this is the maximum time that excess idle threads will wait for new tasks before terminating.
// unit – the time unit for the keepAliveTime argument
// workQueue – the queue to use for holding tasks before they are executed. This queue will hold only the Runnable tasks submitted by the execute method.
public ThreadPoolExecutor(int corePoolSize,
    int maximumPoolSize,
    long keepAliveTime,
    TimeUnit unit,
    BlockingQueue&lt;Runnable&gt; workQueue) {
this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
Executors.defaultThreadFactory(), defaultHandler);
}</code></pre>
                    <h4>public interface Future&lt;V&gt;</h4>
                    <p>Used to store a result (status details) of <code>submit()</code> method of the <strong>ExecutorService</strong> interface.</p>
                    <p>It is available just after the call of the <strong>ExecutorService</strong> hence you can check the status of the task immediately and not only after it is done.</p>
<pre><code>// Returns true if a task is done
boolean isDone()
// Waits if necessary for the computation to complete, and then retrieves its result.
// Returns: the computed result. Result consist of whatever is returned to it.
V get()
// Cancels a task
boolean cancel(boolean mayInterruptIfRunning)</code></pre>

                    <h4>public Interface Callable&lt;V&gt;</h4>
                    <p>Has only one method <code>call()</code>, but returns a result. In this regard more flexible then <strong>Runnable</strong>. <strong>V</strong> parameter represents return type.</p>
<pre><code>call()</code></pre>

                    <h4>>public interface ScheduledExecutorService extends ExecutorService</h4>
                    <p>...</p>

                    <h4>public class Executors</h4>
                        <p></p>
<pre><code>// Params: nThreads – the number of threads in the pool. They will work in parallel. If only one Thread is allowed then there will be no parallel execution.
// Returns: the newly created thread pool
public static ExecutorService newFixedThreadPool(int nThreads)
// Calls to execute will reuse previously constructed threads if available. If no existing thread is available, a new thread will be created and added to the pool. Threads that have not been used for sixty seconds are terminated and removed from the cache.
// Returns the newly created thread pool
public static ExecutorService newCachedThreadPool()

// Another way to create a Thread pool. Runs after a given delay, or to execute periodically.
// Params: corePoolSize – the number of threads to keep in the pool, even if they are idle.
public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)
// Used in pairs with the newScheduledThreadPool to schedule a task.
public ScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit)</code></pre>

                <h2>Collectors</h2>
                <p>Information to be added ...</p>
                <h2>SimpleDateFormat</h2>
                <p>Information to be added ...</p>
                <h2>System</h2>
                <p>Information to be added ...</p>
<pre><code>// returns HashCode of an object.
public static native int identityHashCode(Object x)</code></pre>
                <h2>Application structure</h2>
                <ul>
                    <li><strong>controller</strong> Intermediate between Model and View. Distribute business-logic and presentation. Manipulates data flow. Assigns responsible for data calculation</li>
                    <li><strong>entity</strong> E.g. Customer, Product.</li>
                    <li><strong>exceptions</strong></li>
                    <li>
                        <strong>model</strong> Contains a business-logic (payments, etc.)
                        <ul>
                            <li>impl</li>
                        </ul>
                    </li>
                    <li>
                        <strong>units</strong>
                        <ul>
                            <li>constants</li>
                        </ul>
                    </li>
                    <li><strong>validator</strong></li>
                    <li>
                        <strong>view</strong> Shows data and result of data manipulation
                        <ul>
                            <li><strong>fragments</strong> Such as orderDelivery, error, etc.</li>
                        </ul>
                    </li>
                    <li><strong>App.js</strong> <code>AppStarter.runApp();</code></li>
                </ul>
                <h2>Generics Types</h2>
                <p>Parameterized (Generics) types allow you to declare classes, interfaces, and methods where the data type they operate on is specified as a parameter, such classes, interfaces and methods are called Generics. It is used by other classes as a Generic Template for objects creation, which allows them to manipulate different types of input data using a common framework.</p>
                <ul>
                    <li>
                        Generics works only with Objects, but not with the primitive type.
                        <code>Product&lt;Integer&gt;</code>, but not <code>Product&lt;int&gt;</code>
                    </li>
                </ul>
                <h3>Type Parameter Naming Conventions</h3>
                <ul>
                    <li><code>T</code> - Type: Float; Double, etc.</li>
                    <li><code>V</code> - Value</li>
                    <li><code>E</code> - Element</li>
                    <li><code>K</code> - Key</li>
                    <li><code>N</code> - Number</li>
                    <li><code>S</code>, <code>U</code> etc. - 2nd, 3rd, 4th types</li>
                </ul>
                <h3>Generic Classes</h3>
                <ul>
                    <li>
                        <strong>Create a Class</strong>
<pre><code>public class GenericEntity&lt;T, S&gt; {

    private final T propA;
    private final S propB;

    public GenericEntity(T propA, S propB) {
        this.propA = propA;
        this.propB = propB;
    }

    public T getPropA() {
        return propA;
    }

    public S getPropB() {
        return propB;
    }
}</code></pre>
                    </li>
                    <li>
                        <strong>Initialize an Object</strong>
<pre><code>GenericClass&lt;T&gt; object = new GenericClass&lt;&gt;();</code></pre>
                        <p>With a specified type</p>
<pre><code>GenericClass&lt;String, Double&gt; object = new GenericClass&lt;&gt;(name, price);</code></pre>
                    </li>
                </ul>
                <h3>Generic Interface</h3>
                <p>The Generic Interface is created in the same way as and Classes.</p>
                <ul>
                    <li>
                        A class that implements a generic interface must be generic.
<pre><code>public class ProductA&lt;T&gt; implements IProduct&lt;T&gt; { ... }</code></pre>
                    </li>
                    <li>
                        A non-generic class can be used if a concrete type (Integer, String, Double, etc.) is provided with the interface in the implementation.
<pre><code>public class ProductB implements IProduct&lt;String&gt; { ... }</code></pre>
                    </li>
                    <li>
                        A generic class that implements a generic interface can have other parameters of a parameterized type.
<pre><code>public class ProductC&lt;T, U&gt; implements IProduct&lt;T&gt; { ... }</code></pre>
                    </li>
                </ul>
                <h3>Generic methods</h3>
                <p>Does not matter what is output, the method will attach needed data Type.</p>
<pre><code>public class GenericExample {
    public &lt;T&gt; void displayGenType(T type) {
        System.out.println(type.getClass().getName() + " = " + type);
    }

    public static void main(String[] args) {
        GenericExample example = new GenericExample();
        example.displayGenType("Hello");
        example.displayGenType(123);
        example.displayGenType(45.67);
    }
}</code></pre>
                <h3>Bounded type</h3>
                <p>Typically, a type parameter can accept any data type (except primitive types). However, if we want to use generic templates for only some specific types (for example, accept numeric data types, Number), we can use restricted types. In the case of restricted types, we use the <code>extends</code> keyword.</p>
<pre><code>class Outputer&lt;T extends Number&gt; { ... }
// List&lt;? extends Number&gt; means a list of objects that are instances of the Number class or its subclasses (for example, Integer or Double).
// The List&lt;? extends Number&gt; list parameter uses a wildcard with an upper limit, where Number is the upper bound</code></pre>
                <h2>Wildcard</h2>
                <ul>
                    <li>
                        <strong>Upper bounded wildcard</strong>
<pre><code>private static Double addNums(List&lt;? extends Number&gt; list) { ... }
// List&lt;? super Double&gt; means that the list is typed either by the Double class, or its superclass Number.
// The List&lt;? super Double&gt; list parameter uses a wildcard with a lower limit, where Double is the lower bound
// You can use instances of Number or its subclass Double.</code></pre>
                    </li>
                    <li>
                        <strong>Lower bounded wildcard</strong>
<pre><code>private static void getNums(List&lt;? super Double&gt; list) { ... }</code></pre>
                    </li>
                    <li>
                        <strong>Unbounded wildcard</strong> - 
<pre><code>public static void displayData(List&lt;?&gt; list) { ... }
// List&lt;?&gt; means the list is typed by any class
</code></pre>
                    </li>
                </ul>
                <section>
                <h2 class="section">Links to helpful websites</h2>
                <ul>
                    <li><a href="https://jenkov.com/tutorials/java-concurrency/java-memory-model.html">The Java Memory Model And The Hardware Memory Architecture</a></li>
                    <li><a href="https://jenkov.com/tutorials/java-concurrency/volatile.html">Java Volatile Keyword</a></li>
                    <li><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html">String Object</a></li>
                    <li><a href="https://www.baeldung.com/java-string-operations">Common String Operations</a></li>
                </ul>
            </section>
            <section>
                <h2 class="section">Questions which I have got</h2>
            </section>
        </div>
        <ul class="sticky-element">
            <li class="left-tiem">
                <a href="../20/index.html">
                    <button class="arrow">
                        <span class="arrow-previous"></span>
                    </button>
                </a>
            </li>
            <li class="right-tiem">
                <a href="../22/index.html">
                    <button class="arrow">
                        <span class="arrow-next"></span>
                    </button>
                </a>
            </li>
        </ul>
    </main>
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
</body>

</html>